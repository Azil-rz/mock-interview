{
  "questions": [
    {
      "question": "设计模型可以被分成哪些？",
      "answer": "创建型模式：涉及到对象的创建机制，帮助创建对象时同时隐藏创建逻辑，而不是使用new直接实例化对象。这些模式提供了创建对象的最佳方式。例如，单例模式（Singleton）保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n结构型模式：关注类和对象的组合，继承的替代方案，用于将接口和实现分离开来帮助我们得到更大的结构。例如，适配器模式（Adapter）可以让不兼容的接口通过一定的转换能够一起工作。\n\n行为型模式：关注对象之间的通信，这些模式提供了增强对象间责任划分和算法封装的方法。例如，观察者模式（Observer）定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。"
    },
    {
      "question": "什么是高内聚、低耦合的设计原则？",
      "answer": "“高内聚”和”低耦合”是软件设计的两个重要原则，它们帮助我们提高代码的可读性、可维护性和可复用性。\n\n高内聚 (High Cohesion)\n\n内聚性是指模块内部元素之间的功能关联性。高内聚意味着一个模块或一个类只做一件事，它的责任清晰，所有的相关功能都集中在一起。\n\n例如，如果你有一个处理文件操作（如读取、写入、删除等）的类，那么这个类就应该只包含与文件操作相关的代码，而不应该包含其他与文件操作无关的功能，比如网络请求或者数据库查询等。\n\n高内聚的好处包括：\n\n提高了模块的独立性，使其更容易理解和维护。\n提高了模块的可复用性，因为它们执行的功能非常明确。\n改善了系统的健壮性，因为改变的影响被限制在了单个模块内部。\n低耦合 (Low Coupling)\n\n耦合性是指模块之间的关系密切程度。低耦合意味着各个模块之间的依赖关系降到最低，模块之间的接口尽可能简单。\n\n例如，两个类或模块应该通过定义清晰的接口进行交互，而不是直接访问对方的内部实现。这样，当一个模块需要修改时，不会影响到其他的模块。\n\n低耦合的好处包括：\n\n提高了模块的独立性，模块之间的改动不会相互影响。\n提高了系统的可维护性，因为可以分别修改或者替换模块，而不影响其他部分。\n提高了系统的可扩展性，可以很容易地添加或替换模块。\n总的来说，”高内聚、低耦合”的设计原则，是为了使软件系统更容易理解、更容易修改和更容易扩展。"
    },
    {
      "question":"设计模式的六大基本原则是什么？",
      "answer": "设计模式的六大原则是软件工程中的一些基本准则，它们有助于我们编写出高质量的、易于维护和扩展的代码。这六大原则包括：\n\n单一职责原则（Single Responsibility Principle，SRP）:\n一个类应该只有一个引起变化的原因。换句话说，一个类应该只负责一项职责。\n里氏替换原则（Liskov Substitution Principle，LSP）:\n如果对每一个类型为 S 的对象 o1，都有类型为 T 的对象 o2，使得以 T 定义的所有程序 P 在所有的对象 o1 都代换 o2 时，程序 P 的行为没有发生变化，那么类型 S 是类型 T 的子类型。简单地说，子类型必须能够替换掉它们的基类型。\n\n依赖倒置原则（Dependency Inversion Principle，DIP）:\n高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。换句话说，要依赖抽象（接口和抽象类），不要依赖具体类。\n\n接口隔离原则（Interface Segregation Principle，ISP）:\n客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应建立在最小的接口上。\n\n开闭原则（Open Closed Principle，OCP）:\n软件实体（类、模块、函数等等）应当对扩展开放，对修改关闭。也就是说，软件实体应当在不修改原有代码的基础上，通过添加新代码来实现新功能。\n\n迪米特法则（Law of Demeter，LoD） 或 最少知识原则（Least Knowledge Principle，LKP）:\n一个对象应该对其他对象有最少的了解，只和你的直接朋友交谈，不和”陌生人”说话。也就是说，避免过度交互，使系统的功能模块能够相对独立。"
    },
    {
      "question":"怎么理解单一职责原则?",
      "answer": "单一职责原则（Single Responsibility Principle, SRP）是面向对象设计五大原则（SOLID）中的第一个。简单来说，这个原则指的是一个类应该只有一个引起它变化的原因，也就是说一个类应该只负责一项职责。\n\n举个例子，假设我们有一个用于管理员工信息的类Employee。按照单一职责原则，这个类应该只关心员工信息的管理，比如员工的姓名、年龄、地址等属性的获取和设置。如果这个类中还包含了计算工资、处理税务或者管理员工考勤的方法，那么它就承担了额外的职责，违反了单一职责原则。\n\n为什么要遵循单一职责原则？主要有以下几点好处：\n\n维护性：当一个类只负责一项任务时，它的逻辑会更简单，也就更容易维护和理解。\n可读性：职责划分清晰的代码更容易阅读，新的开发者可以更快地理解代码库。\n可扩展性：当需求变更时，如果一个类的职责单一，修改引起的影响范围较小，更易于扩展。\n可重用性：职责单一的类可以在不同的程序中重用，不需要担心会带来不需要的功能。\n在实际应用中，遵循单一职责原则有助于我们设计出高内聚、低耦合的系统，使系统各部分更加独立、灵活。"
    },
    {
      "question":"工厂模式的基本定义是什么？它有哪些具体的应用场景？",
      "answer": "工厂模式是一种创建型设计模式，它提供了一种创建对象的方式，使得具体实现类的创建逻辑从客户代码中解耦出来，使得客户代码不需要关心具体的对象是如何被创建出来的。工厂模式主要有三种形式：简单工厂、工厂方法和抽象工厂。\n\n简单工厂（Simple Factory）：简单工厂其实并不是一个设计模式，更多的是一种编程习惯。它的主要思想是创建一个工厂类，你可以通过传入参数或者条件，然后在工厂类中使用 switch 或者 if-else 语句来产生不同的类实例。\n工厂方法（Factory Method）：工厂方法是一个真正的设计模式，它定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。\n\n抽象工厂（Abstract Factory）：抽象工厂模式提供了一种方式，可以将一组具有同一主题的单独的工厂封装起来。在正常使用中，客户程序需要创建一个ConcreteFactory的对象，然后利用这个对象创建一系列的产品。"
    },
    {
      "question":"装饰器模式的基本定义是什么？",
      "answer": "装饰器模式是一种设计模式，允许在不改变现有对象结构的情况下附加功能或行为到一个对象上。这种模式的主要思想是通过将对象封装在装饰器类中，可以动态地增加或修改对象的行为。装饰器模式是一种结构型设计模式，其主要目标是促进代码复用，并增加代码的灵活性。\n\n这个模式通常由四个元素组成：\n\n组件：这是我们想要增加新行为的对象。\n装饰器抽象：这是一个接口或抽象类，它有一个方法，该方法获取组件对象。\n具体装饰器：这是实现装饰器抽象的类。它包含了新增的行为或状态。\n客户端：使用装饰器和组件的代码。"
    },
    {
      "question":"里氏替换原则在面向对象设计中的作用是什么？",
      "answer": "里氏替换原则（Liskov Substitution Principle，LSP）是面向对象设计的五大原则（SOLID）中的第三个原则。这个原则由美国计算机科学家芭芭拉·利斯科夫（Barbara Liskov）提出，因此得名。\n里氏替换原则的核心思想是：“子类必须能够替换其基类（超类）并出现在基类能够出现的任何地方，而不改变原有的属性和行为”。也就是说，任何使用基类的地方，如果替换为子类，程序的行为不应该发生改变。\n这个原则的含义是，子类的行为必须与父类的行为保持一致，子类只能扩展父类的行为，但不能改变父类原有的行为。如果不遵守这个原则，那么使用多态特性的地方在运行时就可能出现错误。\n\n举个例子，假设我们有一个Rectangle类（矩形），它有width（宽）和height（高）两个属性，还有一个setHeight方法和一个setWidth方法来设置高和宽。现在我们想要添加一个Square类（正方形）。按照常识，正方形是一种特殊的矩形，因此Square类应该继承Rectangle类。但是，正方形的高和宽是相等的，如果我们调用setHeight方法或setWidth方法来单独设置高或宽，那么Square类的行为就会与Rectangle类的行为不一致。这就违反了里氏替换原则。\n\n遵循里氏替换原则可以带来以下好处：\n\n提高代码的可重用性：如果子类的行为与父类保持一致，那么我们就可以在不改变代码的情况下使用子类来替换父类。\n提高代码的可扩展性：如果我们想要扩展系统的功能，只需要添加新的子类，而不需要修改现有的代码。\n提高代码的可维护性：由于子类的行为与父类保持一致，因此我们可以更容易地理解和维护代码。\n"
    },
    {
      "question":"CGLib是什么？",
      "answer": "CGLIB（Code Generation Library）是一个开源项目，它是一个强大的、高性能、高质量的代码生成类库，可以在运行时扩展Java类与实现Java接口。CGLIB是用来扩展Java类和实现Java接口的强大的高级类库。\n\nCGLIB主要被许多AOP（面向切面编程）框架以及框架如Spring用于实现方法拦截，其中的方法拦截是通过生成一个被代理对象的子类实现的，利用字节码处理技术生成代理类，可以在运行时动态扩展Java类。\nCGLIB提供的一个主要特性是能够在运行时动态地生成和加载新的Java类。CGLIB使用了ASM开源项目，以字节码的形式动态生成和加载类。这样的技术可以用来生成动态代理对象，但也有其他的用途，如创建复杂的数据对象或进行类和方法的运行时修改。\nCGLIB动态代理与JDK动态代理的一个主要区别是，CGLIB可以代理类而不仅仅是接口。因为它是通过生成一个新的类来创建代理的，这个新类是原始类的子类，所以它可以覆盖原始类的非final方法。然而，这也意味着无法代理final类或final方法。"
    },
    {
      "question":"在Java设计原则中，为何推荐组合优于继承？",
      "answer": "在Java设计原则中，推荐“组合优于继承”（Composition over inheritance）主要是因为以下几个原因：\n更大的灵活性：通过组合，一个类可以使用多个对象的功能，而这些对象可以在运行时动态替换或增加，提供了更大的灵活性。而继承是静态的，一旦定义了子类，就不能在运行时改变从父类继承的实现。\n避免过度耦合：继承会造成父类和子类之间的紧密耦合，因为子类依赖于父类的实现细节。父类的任何改变都可能影响子类。组合则可以降低对象间的耦合度，因为它们之间通常只通过接口或者定义好的协议进行交互。\n更易于维护：使用组合的对象的内部实现可以独立于使用它的类变化，这意味着对象可以不影响其它类的情况下进化和变化。这使得系统更易于维护和扩展。\n避免继承层次过深：继承可能导致很深的继承层次结构，这使得代码难以理解和维护。组合通过简单地组合对象来实现功能，可以避免创建复杂的继承结构。\n重用代码：组合可以更方便地重用代码。你可以将功能封装在各种对象中，然后通过组合它们来创建新的功能。这比通过继承来重用代码更加灵活。"
    },
    {
      "question":"实现动态代理主要有哪些方法？",
      "answer": "在 Java 中，实现动态代理主要有以下几种方式：\nJDK 动态代理：Java 的核心库提供了动态代理的支持。可以使用 java.lang.reflect.Proxy 类和 java.lang.reflect.InvocationHandler 接口来创建动态代理。JDK 动态代理主要是通过反射机制来实现的，因此只能代理实现了接口的类。\nCGLib 动态代理：CGLib 是一个第三方库，它可以在运行时动态生成一个子类来扩展某个类的功能，因此它可以代理没有实现接口的类。CGLib 使用了 ASM（一个 Java 字节码操作库）来生成代理类。\nByteBuddy：ByteBuddy 是一个更现代的库，它提供了一个流畅的 API 来动态创建和修改 Java 类。ByteBuddy 可以用来创建动态代理，它比 JDK 和 CGLib 提供的方式都更灵活、更强大。\nJavassist：Javassist 是一个开源的分析、编辑和创建 Java 字节码的库，它也可以用来创建动态代理。"
    },
    {
      "question":"迪米特原则（最少知道原则）的核心思想是什么？",
      "answer": "迪米特原则（Law of Demeter，LoD）有时也被称为最少知道原则（Least Knowledge Principle，LKP），它是一个用于降低系统之间耦合度的设计原则。这个原则的核心思想是：一个对象应该对其他对象保持最少的了解，或者说，一个软件实体应尽可能少地与其他实体进行交互。\n\n在具体应用迪米特原则时，通常遵循以下几个规则：\n\n每一个软件单位对其他的单位只有最少的知识，而且局限于那些与本单位密切相关的软件单位。\n在类的结构设计上，任何类都只应该有直接的朋友，而没有间接的朋友。如果两个类之间的关系较为复杂，可以通过引入一个第三者（如中介类或者服务类）来进行解耦。\n对于被依赖的类来说，无论逻辑多么复杂，都应该将逻辑封装在类内部，通过public方法提供给外部，而不应该泄露给调用的类。\n举个例子，假设我们有一个Customer类和一个Order类，Customer类有一个placeOrder()方法，该方法需要调用Order类的calculateTotalPrice()方法来计算订单总价。按照迪米特原则，Customer类不应该直接调用Order类的calculateTotalPrice()方法，而是应该通过Order类的public方法（如getTotalPrice()）来获取订单总价，calculateTotalPrice()方法应该被封装在Order类内部。\n\n遵循迪米特原则可以带来以下好处：\n\n降低耦合度：由于每个类只和需要交互的类有所交互，因此，系统的各个类之间的耦合度会降低，整个系统的结构会更加清晰。\n提高可读性和可维护性：由于每个类的复杂性降低，代码会更加容易理解和维护。\n提高代码的健壮性：由于类和类之间的依赖性降低，因此，一个类的改变不太可能影响到其他的类，提高了代码的健壮性。\n但是，需要注意的是，过度应用迪米特原则可能导致系统中类的数量过多，增加了系统的复杂性。因此，在实际的设计中，我们需要在遵循原则和保持系统的简洁性之间找到一个平衡。"
    },
    {
      "question":"动态代理的定义？",
      "answer": "动态代理是一种设计模式，它在运行时动态地创建并管理代理对象。与静态代理不同，动态代理不需要手动创建代理类，而是在运行时动态生成。这种方式更灵活，可以减少代码量，提高代码复用性。\n\n动态代理的关键在于使用了反射机制。在Java中，可以使用java.lang.reflect.Proxy类来创建动态代理。这个类有一个newProxyInstance方法，可以生成一个实现指定接口的新的代理实例。这个方法需要三个参数：类加载器、一组接口、以及一个调用处理器（InvocationHandler）。调用处理器是一个实现了java.lang.reflect.InvocationHandler接口的对象，它定义了一个invoke方法，当对代理实例的方法进行调用时，这个方法会被执行。"
    },
    {
      "question":"Spring框架中的Bean默认是单例还是多例？",
      "answer": "在Spring框架中，“单例”指的是每个Spring IoC容器中只有一个Bean实例，而不是在Java虚拟机（JVM）层面的单例。这种单例模式是Spring框架中的默认作用域。\n\nSpring的单例和传统意义上的单例模式（即确保一个类只有一个实例，并且提供一个全局的访问点）略有不同。在Java中实现的单例模式通常是指无论在应用中创建多少次，都只会有一个实例，且通常是线程安全的。但Spring的单例是相对于每个Spring IoC容器来说的，如果你在同一个应用中配置了多个Spring IoC容器，每个容器都可以创建各自的单例Bean，因此在整个应用中就可能存在多个Bean实例。\n\n此外，Spring的单例Bean默认不是线程安全的。如果多个线程同时访问同一个Spring单例Bean，而Bean内部有共享的状态，就可能会出现线程安全问题。如果需要，开发者需要自己来管理这些Bean的线程安全。"
    },
    {
      "question":"依赖倒置原则对软件开发有哪些指导意义？",
      "answer": "依赖倒置原则（Dependency Inversion Principle，DIP）是面向对象设计的五大原则（SOLID）中的最后一个原则。这个原则的核心思想是“高层模块不应该依赖低层模块，两者都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象”。\n\n让我们分解一下这个原则的两部分：\n\n高层模块不应该依赖低层模块，两者都应该依赖抽象：这意味着我们应该将系统中的具体实现（低层模块）和高级策略（高层模块）分离开来，二者都应该依赖于抽象接口或抽象类。通过这样的设计，我们可以降低高层模块与低层模块之间的耦合度，提高系统的灵活性和可扩展性。\n抽象不应该依赖细节，细节应该依赖抽象：这意味着抽象接口或抽象类不应该依赖于具体的实现，而具体的实现反而应该依赖于抽象。这可以确保我们在不改变抽象的情况下修改或添加具体的实现。\n遵循依赖倒置原则有以下好处：\n\n降低耦合度：由于高层模块和低层模块都依赖于抽象，因此我们可以很容易地替换具体的实现，而不需要修改高层模块的代码。\n提高可维护性和可扩展性：当需求发生变化时，我们可以通过添加新的实现类来扩展系统，而不需要修改现有的代码。\n提高可测试性：在测试高层模块时，我们可以通过Mock抽象接口来隔离依赖，使得单元测试更加容易。\n但是，需要注意的是，依赖倒置原则并不是说我们应该避免所有的直接依赖，而是鼓励我们在设计时考虑到系统的长期演进，尽可能使高层模块依赖于稳定的、不易变化的抽象，从而提高系统的稳定性和可维护性。"
    },
    {
      "question":"代理模式的基本定义是什么？",
      "answer": "代理模式是一种结构型设计模式，它为另一个对象提供一个替身或占位符，以控制对这个对象的访问。这个模式的关键在于引入了一个额外的间接层，让代理对象控制客户端对实际对象的访问，这可以用于访问控制、延迟初始化、日志记录、监控、网络通信、负载平衡等。\n\n代理模式主要有三种类型：\n\n静态代理：由程序员创建或工具自动生成源代码，然后编译成代理类。\n动态代理：在运行时动态创建代理类和对象。\n虚拟代理：在需要时才实例化真正的对象，常用于资源密集型对象的延迟初始化。"
    }
  ]
}