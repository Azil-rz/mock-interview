{
  "questions": [
    {
      "question": "计算机网络五层模型",
      "answer": "物理层：负责把两台计算机连起来，然后在计算机之间通过高低电频来传送0,1这样的电信号，比如通过一些电缆线传输比特流。\n\n链路层：链路层涉及到的协议比较多，比如 Mac 地址啊，ARP 等，这一层主要就是负责数据的通信，使各节点之间可以通信，比如通过 MAC 地址唯一识别不同的节点，通过以太网协议定义数据包等。\n\n网络层：网络层负责把一个数据从一个网络传递到另外一个网络，最大的功能就是进行路由决策，比如通过 IP，子网等概念，使数据更好着在不同的局域网中传递。\n\n传输层：传输层的功能就是建立端口到端口的通信，刚才说的网络层的功能则是建立主机到主机的通信，比如通过网络层我们可以把信息从 A 主机传递到 B 主机，但是 B 主机有多个程序，我们具体要发给哪个程序，则是靠传输层的协议来识别，常见协议有 UDP 和 TCP。\n\n应用层：接收到的数据格式多样，有html格式的，有mp4格式的，因此需要指定这些数据的格式规则，收到后解读渲染。"
    },
    {
      "question": "IP 地址和 Mac 地址的区别",
      "answer": "1.IP地址是逻辑地址，而MAC地址是物理地址。\n2.IP地址是在网络层使用的地址，用于标识网络上的主机或路由器，MAC地址则是在数据链路层使用的地址，用于标识网络上的网卡或其他物理设备。\n3.IP地址是可变的，可以在网络上动态分配或更改，而MAC地址是固定的，通常是出厂时设定的。\n4.IP地址是全球唯一的，由互联网号码分配机构（IANA）管理分配，而MAC地址是由设备厂商分配，通常在设备生产时就已经固定。"
    },
    {
      "question": "三次握手",
      "answer": "刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后\n\n1、第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。\n\n2、第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。\n\n3、第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。\n\n4、服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接"
    },
    {
      "question": "四次握手",
      "answer": "刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：\n\n1、第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。（大白话：相当于客户端告诉服务端，我想断开链接了）\n\n2、第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。（大白话：相当于，服务端告诉客户端，好的，我收到你的断开请求了）\n\n3、第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。\n\n4、第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态\n\n5、服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。"
    },
    {
      "question": "为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？",
      "answer": "1、为了保证 A 发送的最后一个 ACK 报文段能够到达 B。\n\nA 发送的 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对方已发送的 FIN + ACK 报文段的确认。这时 B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次 ACK 报文确认，并且重新启动 2MSL 计时器。\n\n最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。\n\n2、 防止已失效的连接请求报文段出现在本连接中。\n\nA 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。"
    },
    {
      "question": "TCP与UDP的区别",
      "answer": "（1）TCP是面向连接的传输层协议，所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程；而 UDP 则是无连接的传输协议。\n\n（2）TCP 可以提供可靠的传输，比如数据丢失，超时，TCP 都会重传，并且数据包也能够按序到达，而 UDP 是不可靠的，数据丢失了也不会重传等等。\n从效率的角度讲，UDP 的效率更快，因为 UDP 不需要做诸如三次握手/四次挥手/重传等额外的消耗。\n\n那从应用场景角度讲的话，对信息的正确率要求比较高的可以采用 TCP 协议，比如我们平时常见的文字聊天；而允许出现小部分数据丢失的，则可以采用 UDP，比如视频聊天等。\n\n像HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议。"
    },
    {
      "question": "TCP 和 UDP 分别对应的常见应用层协议有哪些？",
      "answer": "1.TCP 对应的应用层协议\n\nFTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。\n\nTelnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。\n\nSMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。\n\nPOP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件。\n\nHTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。\n\n2. UDP 对应的应用层协议\n\nDNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。\n\nSNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。\n\nTFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。"
    },
    {
      "question": "浏览器对同一 Host 建立 TCP 连接到的数量有没有限制？",
      "answer": "浏览器对同一Host建立的TCP连接数量是有限制的。这个限制情况主要依赖于浏览器的类型和版本，以及特定的浏览器配置。\n\n以HTTP/1.1协议为例，根据其规范，对于同一个给定的域，大多数浏览器限制同时打开的TCP连接数量为6个到8个。这意味着，如果一个网页需要获取该域下的更多资源，可能需要等待前面的请求完成。\n\n但是，在HTTP/2协议中，对于同一个域，所有的请求都可以在同一个持久连接中并行完成，从而减少了所需的连接数量。\n这个限制只针对同一个Host。如果一个网页的资源分布在不同的Host上，那么浏览器可以分别针对这些Host建立连接。因此，使用多个子域（比如：img1.example.com，img2.example.com）去托管网站的资源是一种常见的绕过浏览器连接限制的方式，以提高加载效率。"
    },
    {
      "question": "HTTP1.0，1.1，2.0 的区别",
      "answer": "1.HTTP/1.0\n\n1996年5月，HTTP/1.0 版本发布，为了提高系统的效率，HTTP/1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。\nHTTP/1.0中浏览器与服务器只保持短暂的连接，连接无法复用。也就是说每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\n2.HTTP/1.1\n\n为了解决HTTP/1.0存在的缺陷，HTTP/1.1于1999年诞生。相比较于HTTP/1.0来说，最主要的改进就是引入了持久连接。所谓的持久连接即TCP连接默认不关闭，可以被多个请求复用。\n客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。或者客户端在最后一个请求时，主动告诉服务端要关闭连接。\nHTTP/1.1版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。\n3.HTTP/2\n\nHTTP/2 是 HTTP 协议自 1999 年 HTTP 1.1 发布后的首个更新，主要基于 SPDY 协议。\n\nHTTP/2 为了解决HTTP/1.1中仍然存在的效率问题，HTTP/2 采用了多路复用。即在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。能这样做有一个前提，就是HTTP/2进行了二进制分帧，即 HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码。"
    },
    {
      "question": "什么是DDos攻击？",
      "answer": "DDoS（Distributed Denial of Service）攻击是指利用多个不同的计算机或网络设备，协同发起大规模的拒绝服务攻击。攻击者通过控制大量的僵尸计算机（也称为“肉鸡”或“僵尸网络”）或利用其他合法的网络设备，向目标服务器或网络发起大量的请求，使其无法正常响应合法用户的请求。\n\nDDoS攻击的目标是使目标服务器或网络过载，耗尽其计算资源、网络带宽、处理能力等，导致正常用户无法访问目标服务。攻击方式多种多样，常见的类型包括：\n1.ICMP Flood：发送大量的ICMP（Internet Control Message Protocol）数据包，消耗目标服务器的网络带宽和处理能力。\n2.SYN Flood：发送大量的TCP连接请求的半连接（SYN），使服务器处于半连接打开状态，无法接受新的连接请求。\n\n3.UDP Flood：发送大量的UDP（User Datagram Protocol）数据包，使服务器的目标端口过载，无法处理其他合法的请求。\n\n4.HTTP Flood：发送大量的HTTP请求，以耗尽目标服务器的处理能力，例如发起大量的查询或下载请求。\n5.DNS Amplification：利用存在放大效应的DNS协议，向开放式DNS服务器发送小型请求，从而获得大量响应数据，使目标服务器的网络带宽被占用。\n\nDDoS攻击可以导致服务不可用、网络延迟、数据泄漏以及经济损失，对于网站、在线服务和网络基础设施造成严重影响。为了应对DDoS攻击，可以采取一系列的防御措施，如使用入侵检测和防火墙技术、流量过滤、负载均衡等，以提高网络的安全性和抗DDoS攻击能力。"
    },
    {
      "question": "HTTP 哪些常用的状态码及使用场景？",
      "answer": "状态码分类\n\n1xx：表示目前是协议的中间状态，还需要后续请求\n\n2xx：表示请求成功\n\n3xx：表示重定向状态，需要重新请求\n\n4xx：表示请求报文错误\n\n5xx：服务器端错误\n\n常用状态码\n\n101 切换请求协议，从 HTTP 切换到 WebSocket\n\n200 请求成功，有响应体\n\n301 永久重定向：会缓存\n\n302 临时重定向：不会缓存\n\n304 协商缓存命中\n\n403 服务器禁止访问\n\n404 资源未找到\n\n400 请求错误\n\n500 服务器端错误\n\n503 服务器繁忙"
    },
    {
      "question": "HTTP状态码301是什么？",
      "answer": "301重定向（301 Move Permanently），指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息（header）中包含状态码 301 ，表示该资源已经永久改变了位置。\n\n301重定向是一种非常重要的”自动转向“技术，网址重定向最为可行的一种方法。\n\n哪些情况需要做301重定向？\n\n网页开发过程中，时常会遇到网站目录结构的调整，将页面转移到一个新地址；网页扩展名的改变，这些变化都会导致网页地址发生改变，此时用户收藏夹和搜索引擎数据库中的旧地址是一个错误的地址，访问之后会出现404页面，直接导致网站流量的损失。或者是我们需要多个域名跳转至同一个域名，例如本站主站点域名为 www.conimi.com ，而还有一个域名 www.nico.cc，由于对该域名设置了301重定向，当输入www.nico.cc 时，自动跳转至 www.conimi.com 。\n\n三. 301重定向有什么优点？\n\n有利于网站首选域的确定，对于同一资源页面多条路径的301重定向有助于URL权重的集中。例如 www.conimi.com和 conimi.com 是两个不同的域名，但是指向的内容完全相同，搜索引擎会对两个域名收录情况不同，这样导致网站权重和排名被分散；对conimi.com 做301重定向跳转至www.conimi.com 后，权重和排名集中到www.conimi.com，从而提升自然排名。"
    },
    {
      "question": "HTTP状态码302是什么？状态码301和302的区别",
      "answer": "302重定向（302 Move Temporarily），指页面暂时性转移，表示资源或页面暂时转移到另一个位置，常被用作网址劫持，容易导致网站降权，严重时网站会被封掉，不推荐使用。\n\n301与302的区别\n\n301重定向是页面永久性转移，搜索引擎在抓取新内容的同时也将旧的网址替换成重定向之后的网址；\n\n302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。"
    },
    {
      "question": "每一层对应的网络协议有哪些？",
      "answer": "在OSI模型中，每一层对应的网络协议如下：\n应用层：HTTP、FTP、SMTP、DNS、POP3\n表示层：SSL/TLS、JPEG、GIF、MPEG\n会话层：NetBIOS、RPC\n传输层：TCP、UDP、SCTP\n网络层：IP、ICMP、ARP、OSPF\n数据链路层：以太网、PPP、帧中继、MAC\n物理层：以太网电缆、光纤、集线器"
    },
    {
      "question": "ARP 协议的工作原理？",
      "answer": "网络层的 ARP（地址解析协议） 协议完成了 IP 地址与物理地址的映射。可以让我们通过 IP 地址获取到对应的 MAC 地址\n\n首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。\n\n当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。\n\n此 ARP 请求数据包里包括源主机的 IP 地址、硬件MAC地址、以及目的主机的 IP 地址。\n\n网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败"
    },
    {
      "question": "保活计时器的作用？",
      "answer": "TCP 有一个保活计时器（keepalive timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。\n\n服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔 75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。"
    },
    {
      "question": "TCP 协议是如何保证可靠传输的？",
      "answer": "总的来说，通过确认-重传这种应答机制。\n1.应答机制：TCP协议采用应答机制，即发送端每发送一个数据包就会等待接收端的确认应答。如果发送端在规定时间内没有收到确认应答，就会重新发送数据包，直到接收到确认应答为止。\n2.超时重传：当发送端发送数据包后，在规定时间内没有收到确认应答，就会进行超时重传，重新发送该数据包。\n3.数据校验：TCP协议使用校验和机制对数据包进行校验，以保证传输的数据包没有被篡改。接收端在接收到数据包后，会对其进行校验，如果发现校验和错误，则会丢弃该数据包，并通知发送端进行重传。\n4.滑动窗口：TCP协议采用滑动窗口机制来控制发送端的发送速度，以避免发送过快导致接收端处理不过来。发送端根据接收端的反馈，动态调整发送窗口的大小，以达到最优的传输速率。\n5.流量控制：TCP协议通过流量控制机制来限制发送端的发送速度，以避免网络拥塞。接收端可以通过发送窗口的大小来告诉发送端自己的接收能力，从而控制发送端的发送速度。\n6.拥塞控制：TCP协议通过拥塞控制机制来避免网络拥塞。发送端根据网络的拥塞程度来调整发送速度，以避免过多的数据包在网络中造成拥塞。同时，TCP协议还支持快速恢复和快速重传机制，以更快地适应网络拥塞的变化。"
    },
    {
      "question": "对 ARQ 协议的理解？",
      "answer": "ARQ是 自动重传请求。\n自动重传请求分成为三种，即停等式(stop-and-wait）ARQ，回退n帧（go-back-n）ARQ，以及选择性重传（selective repeat）ARQ。后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大时，帧在线路上可以连续地流动，因此又称其为连续ARQ协议。\n\n所以我们又可以简单分成两种：停止等待协议和连续 ARQ 协议，下面说一下他们的区别有优缺点。\n\n停止等待协议是一种简单的 ARQ 协议，每当发送方发送一个数据包后，就会停止发送并等待接收方的确认信号。只有收到确认信号后，发送方才会继续发送下一个数据包。该协议的缺点是会浪费大量的时间在等待确认信号上。\n\n连续 ARQ 协议是一种改进的 ARQ 协议，它可以在等待确认信号的同时，继续发送其他的数据包，可提高信道利用率。大概就是：发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。"
    },
    {
      "question": "什么是流量控制？",
      "answer": "TCP流量控制是一种内置于TCP协议的机制，用于防止发送方把接收方的缓冲区塞满，以避免数据丢失。简单地说，就是保证发送者不会将数据发送得过快，导致接收者无法接收。\n\nTCP流量控制的工作方式是每个TCP段都有一个窗口大小字段，这个字段告诉发送者接收端的可用缓冲区大小。接收方通过更改这个窗口大小值来告诉发送方他还能接收多少数据。如果接收方的缓冲区被填满了，它就会将窗口大小设置为0，这时发送方就会停止发送数据，直到接收方再次更新其窗口大小。"
    },
    {
      "question": "TCP 是如何实现流量控制的？",
      "answer": "TCP实现流量控制主要依赖于滑动窗口机制。滑动窗口不仅是一种流量控制手段，也是一种可靠传输的手段。它的基本思想是：每个TCP连接都有两个窗口，一个是发送窗口，另一个是接收窗口。窗口大小是动态变化的。\n\n发送窗口的大小由自己和接收方协商得出，不能超过接收窗口的大小。当发送方发送数据时，会根据窗口的大小来确定可以发送的数据量。当数据发送出去后，发送窗口就会向右滑动。\n\n接收方在接收到数据后，会向发送方发送确认，确认号表示的是接收方期望接收的下一个数据字节的序号，同时还会告诉发送方自己的接收窗口大小。\n\n如果接收方处理数据的速度慢，那么接收窗口的大小就会减小，甚至变为0，此时发送方就不能再发送数据，从而实现流量控制。"
    },
    {
      "question": "什么是滑动窗口",
      "answer": "TCP滑动窗口是TCP协议中实现流量控制和可靠传输的关键机制。滑动窗口不仅可以防止发送端数据传输过快，以至于接收端处理不过来，还可以对丢失的数据包进行重传，以确保数据的可靠传输。\n\n工作原理\n\n在TCP连接中，每个方向上都有一个发送窗口和一个接收窗口。窗口的大小是动态变化的，表示接收端目前还能接收的字节数。\n\n当发送端发送数据时，发送的数据不能超过发送窗口的大小。发送的数据被编号，放入发送窗口，并逐个发送出去。每发送一个数据包，发送窗口就向右滑动一个数据包的距离。\n\n接收端在接收到数据包后，会向发送端确认已接收到的数据包序号，并告诉发送端自己的接收窗口大小。接收端的确认可以是累积的，也就是说，如果一次确认了多个数据包，那么需要通知的是最后一个接收到的数据包的序号。\n\n发送端在收到确认后，会把确认的数据从发送窗口中移除，同时根据接收端告知的接收窗口的大小，调整自己的发送窗口大小。然后发送窗口向右滑动，继续发送后面的数据包。\n\n如果发送端没有收到接收端的确认，那么发送端就会重发该数据包。这就是TCP协议如何保证数据的可靠传输的。"
    },
    {
      "question": "什么是TCP粘包和拆包？",
      "answer": "TCP粘包和拆包是网络编程中常见的问题，主要是由于TCP的特性和网络环境的影响。\n\nTCP粘包：简单来说，就是发送方发送的若干包数据到达接收方时被“粘”在一起，接收方看到的可能是一个大的数据包。这主要是因为TCP是一个基于字节流的协议，没有边界。另一个原因是为了提高网络的有效利用率，TCP会尽可能地将小的数据包合并到大的数据包中发送出去。\nTCP拆包：与TCP粘包相反，拆包是指发送方发送的一个大的数据包到达接收方时被“拆”成多个小的数据包。这主要是因为TCP在传输数据时，如果数据包过大，会被分割成合适大小的小包进行发送，以适应网络的最大传输单元（MTU）。"
    },
    {
      "question": "forward 和 redirect 的区别？",
      "answer": "在Web开发中，请求的转发（forward）和重定向（redirect）是常见的两种处理方式，它们的主要区别在于处理的位置和浏览器的行为。\n1.请求转发是在服务器内部进行的。当一个资源（如，Servlet，JSP页）收到客户端（即，浏览器）的请求后，将其转发到另一个资源进行处理，接着将返回的响应发送给客户端。值得注意的是，浏览器是无法察觉到请求转发发生的，即浏览器的地址栏不会有变化，此过程对用户来说是透明的。\n如用户在一个登录表单页面提交了一个登录请求，服务器可能会将这个请求转发到一个处理登录认证的后端资源（比如，Servlet），再将处理结果返回给客户端。\n2.请求重定向涉及到了两次HTTP请求。首先，服务器接收到客户端的请求后，返回一个特殊的响应，这个响应的状态码是302，指示客户端重新向新的URL发起请求。这时，浏览器的地址栏将更新为新的URL。\n假设一个网站的某个页面发生了改变，原来的URL已经不存在了或者变动了，服务器就会发送一个重定向响应，引导客户端重新向新的URL发起请求。\n主要的区别就是：\n转发只有一次请求，不改变URL，服务器内部处理，不交互浏览器；重定向两次请求，改变URL，第一次服务器通过响应告诉浏览器要跳转的URL，第二次由浏览器发起新的请求。\n转发只可以访问服务器内部资源，且可以共享服务器的某些资源；重定向可以访问任何URL，无法共享服务器资源。"
    },
    {
      "question": "HTTP 常见方法有哪些？",
      "answer": "HTTP（超文本传输协议）常见的请求方法有以下几种：\n1.GET：用于请求服务器返回指定资源的数据。通常用于获取或查看资源，GET请求不应该对服务器的状态产生任何影响。\n2.POST：用于向服务器提交数据，请求服务器处理请求中的数据。通常用于提交表单数据、上传文件或者执行某些会修改服务器状态的操作。\n3.PUT：用于向服务器上传或更新资源，请求服务器存储请求中的数据。通常用于更新或上传文件等操作。\n4.DELETE：用于请求服务器删除指定的资源。通常用于删除服务器上的文件或者数据。\n5.HEAD：类似于GET请求，但不返回具体的资源数据，而只返回资源的元信息（例如响应头部），用于获取资源的元信息而不获取实际的资源内容。\n6.OPTIONS：查询服务器支持的HTTP方法。客户端可以使用OPTIONS方法来获取服务器所支持的HTTP方法列表。\n7.TRACE：用于向服务器发送一个请求，服务器将此请求返回给客户端，用于追踪请求的路径。"
    },
    {
      "question": "POST与GET有哪些区别？",
      "answer": "1.使用场景\nGET 用于获取资源，而 POST 用于传输实体主体。\n2.参数\nGET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。POST 参数支持标准字符集。\n3.安全性\n安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。\nGET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。安全的方法除了 GET 之外还有：HEAD、OPTIONS。不安全的方法除了 POST 之外还有 PUT、DELETE。\n4.幂等性\n幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。\n所有的安全方法也都是幂等的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。\n可缓存\n\n如果要对响应进行缓存，需要满足以下条件：\n5.可缓存\n请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。\n6.XMLHttpRequest\n在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。而 GET 方法 Header 和 Data 会一起发送。"
    },
    {
      "question": "在浏览器中输入 URL 地址到显示主页的过程？",
      "answer": "1.URL解析：浏览器首先会解析你输入的URL，确定你要访问的是哪个网站，这个网站的地址（IP地址）是什么，以及你请求访问该网站的具体页面路径。\n2.DNS查询：如果浏览器缓存或系统缓存中没有该域名的IP地址，那么浏览器将发送一个请求到DNS（域名系统）服务器，来查找对应的IP地址。\n3.建立连接：找到IP地址后，浏览器会向该地址发送一个TCP连接请求，这个过程通常被称为TCP的三次握手。\n4.发送HTTP请求：一旦TCP连接被建立，浏览器就可以通过这个连接向服务器发送HTTP请求了。这个请求里会包含你要获取的资源类型，所使用的HTTP版本，以及可能的一些其他信息。\n5.服务器处理请求并返回HTTP响应：服务器接收到HTTP请求后，进行处理，然后返回一个HTTP响应，响应中包含了要访问的网页的内容，以及一些描述信息，如状态码、内容类型等。\n6.浏览器解析HTML：浏览器接收到服务器的响应数据后，开始解析HTML，构建DOM树。\n7.资源加载：在解析HTML的过程中，如果遇到CSS、JavaScript文件或者图片等资源，浏览器会再次发送HTTP请求去获取。\n8。浏览器渲染页面：在获取到所有的资源文件后，浏览器开始渲染页面，将资源文件转化为网页上的可视、可交互的内容。\n9.关闭连接：如果HTTP头部中的Connection字段的属性被设置为close，那么浏览器和服务器的TCP连接在传输完成后将会被关闭。如果设置为keep-alive，那么TCP连接会被保持一段时间，以便传输更多的请求。\n以上就是在浏览器中输入URL地址到显示主页的过程，该过程可能会涉及到网络协议（如DNS、HTTP、TCP/IP等）的一系列操作，请注意实际过程可能会比这更复杂，并且可能会被网络环境、浏览器设定等因素所影响。"
    },
    {
      "question": "DNS 的解析过程？",
      "answer": "DNS（Domain Name System）是互联网中用于将域名解析为IP地址的系统。DNS解析过程主要包括以下步骤：\n1.用户在浏览器中输入一个域名，比如www.example.com。\n2.浏览器首先会在本地缓存中查找是否有该域名对应的IP地址，如果有则直接返回IP地址，否则进入下一步。\n3.浏览器会向本地DNS服务器发送一个查询请求。\n4.本地DNS服务器如果缓存中有该域名对应的IP地址，则直接返回IP地址给浏览器，否则进入下一步。\n5.本地DNS服务器会向根域名服务器发送一个查询请求，询问该域名的顶级域名服务器（比如.com）的IP地址。\n6.根域名服务器会返回顶级域名服务器的IP地址给本地DNS服务器。\n7.本地DNS服务器再次向顶级域名服务器发送查询请求，询问该域名的权威域名服务器（比如example.com）的IP地址。\n8.权威域名服务器返回该域名的IP地址给本地DNS服务器。\n9.本地DNS服务器最后将IP地址返回给浏览器。\n10.浏览器得到IP地址后，就可以向该IP地址对应的服务器发送HTTP请求，建立起与服务器的连接，开始浏览网页。\n这个过程涉及到多个级别的DNS服务器，从根域名服务器到顶级域名服务器再到权威域名服务器，最终找到域名对应的IP地址。这个过程是递归查询的过程，每一级的DNS服务器负责下一级DNS服务器的查询，直到找到IP地址。这样就实现了将域名解析为IP地址的功能。"
    },
    {
      "question": "为了 DNS 解析更多，可以用到哪些优化手段？",
      "answer": "1.DNS缓存：DNS缓存是本地DNS服务器和浏览器中的一种机制，用于缓存已解析的域名和对应的IP地址。当再次访问相同域名时，可以直接从缓存中获取IP地址，避免重复查询和延迟。\n2.域名预取：浏览器可以在用户点击链接之前提前解析网页中的链接中的域名，将这些域名解析为IP地址并缓存起来。这样当用户点击链接时，可以立即建立连接，减少等待时间。"
    },
    {
      "question": "什么是 HTTP 长连接？",
      "answer": "HTTP长连接（HTTP persistent connection）是指在一次HTTP请求和响应完成后，保持TCP连接不关闭，以便后续的HTTP请求可以继续在同一个连接上发送和接收数据。\n在传统的HTTP/1.0版本中，每次请求完成后，TCP连接都会被关闭，下次请求需要重新建立连接，这种方式称为短连接。而在HTTP/1.1版本中，引入了持久连接的概念，也就是HTTP长连接。\nHTTP长连接的主要优势在于减少了TCP连接建立和关闭的开销，提高了性能和效率。相比于短连接，HTTP长连接可以避免频繁地进行握手和挥手操作，节省了网络资源和服务器端的负担。\n通过HTTP长连接，客户端和服务器之间可以在同一个TCP连接上发送多个HTTP请求和接收多个HTTP响应，而不需要每次都重新建立连接。这样可以减少延迟，提高响应速度，特别适用于同时请求多个资源，或在一个页面中含有多个嵌入资源的情况。\n需要注意的是，HTTP长连接并不会一直保持不断开，它有一个超时时间。如果在一段时间内没有新的请求发送，服务器可能会主动关闭连接，或者客户端也可以选择关闭连接。同时，服务器端和客户端都可以通过”Connection”头字段中的选项来控制是否启用长连接。\n总之，HTTP长连接是一种通过保持TCP连接的方式，在一次连接上进行多次请求和响应的机制，以提高性能和效率。"
    },
    {
      "question": "HTTP 和 HTTPS 的区别？",
      "answer": "HTTP（Hypertext Transfer Protocol）和HTTPS（Hypertext Transfer Protocol Secure）是两种不同的协议，用于在客户端和服务器之间传输数据的方式。它们之间的主要区别在于以下几个方面：\n1.安全性：HTTP是明文传输的协议，数据并没有经过加密，容易被窃听、篡改或其他安全风险。HTTPS通过使用SSL（安全套接层）或TLS（传输层安全）协议对HTTP进行加密，确保数据在传输过程中的安全性和完整性。这样，即使被截获的数据也无法被解读和篡改。\n2.端口号：HTTP默认使用端口号80进行通信。HTTPS默认使用端口号443进行通信。\n3.证书：HTTPS使用数字证书对网站的身份进行认证。证书由可信的第三方机构颁发，用于证明服务器是可信的，并且可以用来加密和解密通信过程中的数据。HTTP不需要证书，任何人都可以发送HTTP请求和接收HTTP响应。\n4.性能开销：由于HTTPS需要进行加密和解密操作，因此相对于HTTP来说，会有更多的计算和处理开销，会轻微地增加通信的延迟和资源消耗。\n总的来说，HTTPS是对HTTP的增强和加密升级，提供了更高的安全性。在处理敏感信息、进行用户登录/注册、在线支付等场景中，使用HTTPS更为安全可靠。而在一些不涉及敏感信息的场景，使用HTTP可以提高性能和简化配置。"
    },
    {
      "question": "描述HTTPS流程",
      "answer": "1.客户端发起连接：客户端通过浏览器等应用向服务器发送HTTPS请求。请求的URL以https://开头，表明是要使用HTTPS协议进行通信。\n2.服务器证书：服务器接收到来自客户端的HTTPS请求后，会将自己的数字证书发送给客户端。证书中包含了服务器的公钥，同时由可信的权威机构（证书颁发机构，CA）对服务器的身份进行认证。\n3.客户端验证证书：客户端收到服务器的证书后，会对证书进行验证。主要包括以下几个步骤：\n验证证书的合法性：客户端会检查证书的有效期、签发机构和相关属性，确保证书的合法性。\n验证证书的可信性：客户端会检查证书的颁发机构是否被信任，以确保证书是由可信的第三方机构颁发的。\n4.密钥交换：在证书验证通过后，客户端会生成一个随机的对称加密密钥（session key），并使用服务器的公钥进行加密。然后将加密后的密钥发送给服务器。\n5.会话加密：服务器收到客户端发送的加密密钥后，使用自己的私钥进行解密，得到对称加密密钥（session key）。客户端和服务器都会使用这个对称密钥来加密和解密后续的通信数据。\n6.安全通信：客户端和服务器之间的所有通信都会使用对称密钥进行加密和解密。这样，即使有人拦截到通信数据，也无法解密和获取其中的内容。\n总的来说，HTTPS的工作流程通过使用数字证书对服务器进行身份验证，采用对称加密密钥来加密通信数据，确保了数据传输的安全性和私密性。这样，即使在公共网络上传输敏感信息，也能够保护用户的隐私和数据安全。"
    },
    {
      "question": "什么是对称加密、非对称加密？",
      "answer": "对称加密是一种常用的加密方式，它有一个特点：就是加密和解密使用同一把密钥。也就是说，用这个密钥加密的信息，只有用同样的密钥才能解密。对称加密的速度相对较快，但是密钥的传输和保管比较困难，因为只要这个密钥被泄漏，任何人都可以解密信息。\n非对称加密技术涉及到两个密钥：公钥和私钥。公钥是公开的，任何人都可以见到，并且可以用来加密信息或者验证签名。而私钥则是保密的，只有密钥的主人才能看到，用来解密信息或者生成签名。"
    },
    {
      "question": "什么是 Cookie?",
      "answer": "Cookie是一种在客户端（浏览器）和服务器之间交换的小型数据文件。它由服务器生成并发送给客户端，然后客户端保存在本地的浏览器中。每次浏览器向同一服务器发送请求时，会将相应的Cookie信息附加在请求头中一起发送给服务器。\nCookie主要用于记录和追踪与用户相关的信息，以实现以下功能：\n1.会话管理：通过使用会话Cookie，服务器可以在用户的多个请求之间维持会话状态。它使服务器能够识别特定用户，并保持用户登录状态，而不需要用户在每个请求中重新验证身份。\n2.用户个性化：Cookie可以用于存储用户的个人喜好、偏好或设置等信息。例如，在某个电子商务网站上，可以使用Cookie来记录用户的购物车内容和偏好选项，以便在用户下次访问时进行个性化推荐或还原购物车。\n3.随机广告：Cookie可以用于进行广告跟踪和定向投放。广告商可以在用户访问某个网站时，通过Cookie记录用户的兴趣、浏览行为等信息，然后根据这些信息显示与用户兴趣相关的广告。\n4.记住用户：通过在Cookie中存储持久性数据，网站可以实现”记住我”的功能，使用户在下次访问时不需要重新输入用户名和密码。\n需要注意的是，Cookie是存储在用户本地的浏览器中，它可能包含敏感信息，因此在使用Cookie时需要注意安全性。同时，用户也可以通过浏览器的设置来管理和删除存储的Cookie。\n总的来说，Cookie是一种用于在客户端和服务器之间传递数据的机制，主要用于会话管理、用户个性化、广告跟踪等功能，以提供更好的用户体验和个性化服务。"
    },
    {
      "question": "什么是 Session?",
      "answer": "Session（会话）是指在客户端和服务器之间建立的一种会话状态。通过会话，服务器可以在不同请求之间识别和跟踪特定的客户端，并保持与客户端的交互状态。在Web应用中，Session通常使用一种名为Session ID的机制来实现。当客户端首次访问服务器时，服务器会为此客户端生成一个唯一的Session ID，并将其存储在服务器端的存储介质（如内存、数据库、文件）中，同时将该Session ID发送给客户端保存在Cookie中。\n\n客户端在后续的请求中，会将存储在Cookie中的Session ID自动带上，供服务器在接收到请求时进行识别。然后，服务器根据Session ID找到相应的会话数据，使得服务器能够识别特定的客户端并维持会话状态。\n会话通常用于以下目的：\n1.跟踪用户：通过Session ID，服务器可以记录和存储与特定用户相关的信息，如登录状态、权限、购物车内容等。这样，在用户在同一网站上的不同页面之间，服务器能够保持用户的状态和数据的一致性。\n2.用户验证和安全：Session可以用于验证用户身份，确保只有经过身份验证的用户才能访问特定资源。服务器可以在会话中存储一些敏感信息，如用户ID、角色等，以验证用户的权限和身份。\n3.数据共享：Session使得服务器能够在不同请求之间共享和传递数据。服务器可以将一些重要的数据存储在会话中，以便在后续请求中使用，而不需要每次都重新获取或计算。\n需要注意,会话数据通常存储在服务器端，可以在一段时间后过期或被销毁。同时，会话的安全性也是重要的，敏感数据应该进行加密和保护，防止被恶意窃取。\n总的来说，Session是一种在客户端和服务器之间建立的会话状态，通过Session ID进行识别和跟踪客户端，实现用户的会话管理、身份验证和数据共享。"
    },
    {
      "question": "cookie和session有什么区别？",
      "answer": "Cookie和Session主要有以下几点区别：\n1.存储位置：Cookie数据存储在客户端（浏览器），而Session数据存储在服务器端。因此，从保护用户数据的角度来看，Session比Cookie更安全。\n2.生命周期：通常情况下，Cookie有固定的过期时间，除非用户手动清理否则不会消失，即使关闭浏览器或重启计算机也依然存在。而Session的生命周期通常是在用户关闭浏览器或者超出了设定的时间段后，服务器就会自动将其销毁。\n3.大小限制：由于Cookie数据存储在客户端，所以它有大小限制，一般为4KB左右。而Session是存储在服务器端，理论上其数据大小没有限制，但是如果存储过多的数据会增加服务器的负担。\n4.数据类型限制：Cookie只能保存字符串类型的数据，对于复杂的数据结构需要进行序列化。而Session可以存储任何类型的数据，比如对象和数组等。\n5.跨域问题：基于安全性，Cookie不可以进行跨域名存储，每个域名下的Cookie数据是分开存储的。而Session技术没有这项限制。"
    },
    {
      "question": "什么是ICMP协议？",
      "answer": "ICMP（Internet Control Message Protocol）是一种网络协议，它用于在 IP 网络中传递错误信息和控制消息。ICMP 是在 IP 协议的基础上构建的协议，它是在网络层进行通信的。\nICMP 主要有两个作用：\n1.提供网络的错误报告机制：当在网络通信中发生错误或故障时，ICMP 可以生成错误报告，并将报告发送给源主机。比如，在路由选择失败、目标主机不可达或传输超时等情况下，会发送 ICMP 错误报告给源主机，通知发生了问题。\n2.支持网络的控制消息：ICMP 还支持网络中的控制消息传递。例如，ICMP 可以用于执行网络探测和诊断，如发起 Ping 命令（Echo 请求和 Echo 响应）进行网络连通性测试。\n常见的 ICMP 消息类型包括：\n\nEcho 请求和 Echo 响应：用于网络探测和连接测试。\n目标不可达：当一个数据包无法到达目标时，发送此消息通知源主机。\n超时：当数据包经过一定时间后未能到达目标，发送此消息通知源主机。\n重定向：用于告知主机优化数据包的传输路径。\n时间戳请求和时间戳响应：用于进行时间同步。\nICMP 是一种非常重要的网络协议，在 IP 网络中起着诊断和通信的作用。它协助网络管理员调试和定位问题，在网络通信中起到检测和响应错误的作用，提高网络的可靠性和效率。"
    },
    {
      "question": "IPV4 地址不够如何解决?",
      "answer": "1.IPv6（Internet Protocol Version 6）：IPv6 是 IPv4 的后继协议，扩展了地址空间，从而解决了 IPv4 地址不够的问题。IPv6 地址长度为128位，相较于 IPv4 的32位，地址空间大幅增加，提供了约340亿亿亿亿（3.4 × 10^38）个地址，大大满足了未来互联网发展的需求。逐渐推广 IPv6 技术已成为解决 IPv4 地址不足的主要方式。\n2.NAT（Network Address Translation）：NAT 技术允许一组 LAN 上的计算机共享公共 IPv4 地址。通过使用私有 IP 地址在私有网络中进行通信，然后通过 NAT 设备将私有 IP 地址转换为公共 IPv4 地址，从而使有限的 IPv4 地址资源能够被更多的设备使用。NAT 技术已经被广泛应用于家庭和企业网络中。\n3.IP 地址转换技术：有些技术可以实现 IPv4 和 IPv6 地址之间的转换。例如，双栈技术（Dual-Stack）可以在同一设备上同时支持 IPv4 和 IPv6 协议栈，使设备可以在 IPv4 和 IPv6 网络中通信。还有一些中间设备（如代理服务器和隧道）可以进行 IPv4 到 IPv6 或 IPv6 到 IPv4 的地址转换。\nIPv6 的广泛部署和使用是解决 IPv4 地址不够的长期解决方案。随着 IPv6 的推广，逐渐实现全面的 IPv6 兼容性和过渡将是解决 IPv4 地址短缺问题的主要方式。同时，适用于特定场景的 NAT 和地址转换技术也可以提供临时的解决方案。"
    }
  ]
}