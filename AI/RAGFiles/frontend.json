{
  "questions": [
    {
      "question": "HTML和HTML5的区别？",
      "answer": "HTML 和 HTML5 都是用于创建网页和 Web 应用的标记语言，但 HTML5 提供了更多的特性和功能。以下是一些区别 HTML 和 HTML5 的主要方式：\n1.语义标签：HTML5 引入了一系列新的语义标签，如 <header>, <footer>, <nav>, <section>, <article>, <aside> 等。这些标签使得开发者可以更清晰地描述网页内容的结构和含义。而在 HTML 中，我们通常使用 <div> 和 <span> 等非语义标签来组织和样式化内容。\n2.多媒体和图形支持：HTML5 提供了 <audio> 和 <video> 标签用于在网页中嵌入音频和视频，而在 HTML 中，我们通常需要使用 Flash 或其他插件来播放多媒体内容。此外，HTML5 还引入了 <canvas> 标签，用于在网页上绘制图形和动画。\n3.表单控件和验证：HTML5 增加了许多新的表单输入类型，如 email, tel, number, date 等，以及表单验证属性，如 required, pattern 等。这些新特性使得创建和验证表单变得更加方便。\n4.新的 API：HTML5 提供了一系列新的 JavaScript API，如地理位置（Geolocation）、本地存储（Web Storage）、离线应用缓存（Application Cache）、Web Workers、WebSocket 等。这些 API 使得网页和 Web 应用可以提供更丰富的功能和更好的用户体验。\n5.DOCTYPE 声明：HTML5 的 DOCTYPE 声明更加简单，只需要写 <!DOCTYPE html>。而在 HTML 4.01 中，DOCTYPE 声明要复杂得多，需要包含对 DTD（文档类型定义）的引用。"
    },
    {
      "question":"HTML5为浏览器提供了哪些数据存储方案？",
      "answer": "HTML5为浏览器提供了几种不同的数据存储方案：\n1.LocalStorage：这是一种无期限的数据存储方式，即使浏览器关闭或者电脑重启，数据仍然保存在用户的电脑上。每个域名下可以存储约5MB的数据。\n2.SessionStorage：这是一种临时的数据存储方式，当用户关闭特定的浏览器Tab时，与该Tab相关的数据会被清除。每个Tab都有一个独立的存储空间，一个Tab的数据无法在另一个Tab中访问。\n3.IndexedDB：这是一种在浏览器内部存储大量结构化数据的方式，比如文件/对象。这是一种NoSQL数据库，支持事务处理，数据大小一般限制在 50MB 到 250MB 之间，但可以向用户申请更大的存储空间。\n4.Web SQL Database（已废弃）：这是一种在客户端使用SQL数据库的方式，但是由于标准化问题，这个特性已经被废弃，不推荐使用。\n5.Cookies：虽然Cookies不是HTML5的特性，但是它们仍然是一种常用的小型数据存储方式，主要用于保存用户的登录状态。但是，每个Cookie的大小一般只有4KB，而且每次HTTP请求都会带上所有的Cookie，这可能会浪费带宽。\n6.Cache API：这是一种存储HTTP响应和请求的方式，可以用于创建具有强大离线体验的web应用。\n7.File API：这是一种在浏览器中读取用户本地文件的方式，主要用于上传文件等操作。"
    },
    {
      "question":"CSS3选择器优先级及计算？",
      "answer": "CSS的选择器优先级是一个相对复杂的概念，它规定了在一组样式冲突时，哪些样式将被浏览器采纳。选择器优先级是通过一个四位的值来计算的，形式为：[内联样式, ID选择器, 类选择器/属性选择器/伪类, 元素选择器/伪元素]。这四个等级的优先级从左到右递减，左边的优先级最高，右边的优先级最低。\n\n内联样式：直接在HTML元素中的”style”属性里定义的样式，优先级最高，记为1000。\nID选择器：通过元素的id选择元素，记为0100。\n类选择器、属性选择器、伪类：通过元素的class、属性或者伪类选择元素，记为0010。\n伪元素、元素选择器：通过元素名称或者伪元素选择元素，记为0001。"
    },
    {
      "question":"CSS选择符有哪些?",
      "answer": "CSS选择符（或称选择器）是用来选中页面中特定元素并应用样式的工具。以下是主要的CSS选择器：\n1.元素选择器：这是最基础的选择器，它根据HTML元素的类型进行选择。例如，h1 { color: blue; }会将所有的h1元素的文字颜色设置为蓝色。\n2.ID选择器：通过元素的id属性进行选择，id选择器在CSS中具有很高的优先级。例如，#myId { color: blue; }会将id为myId的元素的文字颜色设置为蓝色。\n3.类选择器：通过元素的class属性进行选择。例如，.myClass { color: blue; }会将class为myClass的所有元素的文字颜色设置为蓝色。\n4.属性选择器：通过元素的属性进行选择。例如，[href] { color: blue; }会将所有含有href属性的元素的文字颜色设置为蓝色。\n5.后代选择器：选中某元素的后代元素。例如，div p { color: blue; }会将所有在div元素内部的p元素的文字颜色设置为蓝色。\n6.子元素选择器：选中某元素的直接子元素。例如，div > p { color: blue; }会将所有直接在div元素下一级的p元素的文字颜色设置为蓝色。\n7.相邻兄弟选择器：选中某元素的下一个兄弟元素。例如，h1 + p { color: blue; }会将所有紧跟在h1元素后面的p元素的文字颜色设置为蓝色。\n8.通用选择器：选中所有元素。例如，* { color: blue; }会将所有元素的文字颜色设置为蓝色。\n此外，CSS3还引入了一些新的选择器，如：\n1.结构伪类选择器：例如:first-child、:last-child、:nth-child()等，用来选择特定位置的元素。\n2.否定伪类选择器：例如:not()，用来选择除某些元素以外的元素。\n3.伪元素选择器：例如::before、::after，用来选择元素的一部分，或者在元素前后插入内容。"
    },
    {
      "question":"对IFC规范的理解？",
      "answer": "在前端开发中，IFC通常指的是”Isolate-Functional-Centralized”规范，这是一种CSS命名和组织的最佳实践。\n1.Isolate（隔离）：每个组件的样式应该是孤立的，不应该依赖于其他组件或全局样式。这样可以避免样式冲突，使得组件更容易重用和维护。\n2.Functional（功能性）：样式应该根据其功能命名，而不是根据其内容或表现形式命名。这样可以使得样式的目的更清晰，更容易理解。\n3.Centralized（集中）：所有的样式应该集中在一处，而不是散布在不同的地方。这样可以使得样式更容易查找和管理。"
    },
    {
      "question":"对GFC规范的理解 ？",
      "answer": "GFC（ GridLayout Formatting Context）指网格布局格式化上下文，即当把一个的 display值设为grid的时候，此元素将会获得一个独立的渲染区域。可以通过在网格容器（ grid container）上定义网格定义行（ grid definition row）和网格定义列（grid definition column），在网格项目（ grid item）上定义网格行（ grid row）和网格列（grid column）来为每一个网格项目定义位置和空间\n\n我想你可能是指的是“BFC”，即 Block Formatting Context（块级格式化上下文）。BFC是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。"
    },
    {
      "question":"对FFC规范的理解？",
      "answer": "FFC（ Flex Formatting Context）指自适应格式化上下文，即 display值为fex或lne-flex的元素将会生成自适应容器。伸缩容器中的每一个子元素都是一个伸缩单元。伸缩单元可以是任意数量的。伸缩单元内和伸缩容器外的一切元素都不受影响。"
    },
    {
      "question":"解释CSS的盒子模型？",
      "answer": "CSS的盒模型是一个用于设计和布局的基本概念，它将HTML元素视为一个矩形的盒子，这个盒子由内到外包含以下几个部分：\n\n内容（Content）：这是盒子里面的实际内容，比如文本、图片等，由width和height属性定义。\n内边距（Padding）：围绕在内容周围的空间，由padding属性定义。内边距是可选的，它的大小会影响到元素的最终尺寸，因为它会增加到内容的宽度和高度上。\n\n边框（Border）：围绕在内边距和内容外的线，由border属性定义。边框是可选的，它的大小同样会影响到元素的最终尺寸。\n\n外边距（Margin）：围绕在边框外部的空间，由margin属性定义。外边距是可选的，它不会影响元素本身的尺寸，但会影响元素与其他元素的距离。\n\n在CSS中，盒模型的尺寸计算有两种模式：标准模式和怪异模式（Quirks Mode）。在标准模式下，元素的总宽度（或高度）= 内容宽度（或高度）+ 左右（或上下）内边距 + 左右（或上下）边框。在怪异模式下，元素的总宽度（或高度）= 内容宽度（或高度），但内容宽度（或高度）包含了左右（或上下）的内边距和边框。"
    },
    {
      "question":"JavaScript中map和foreach的区别？",
      "answer": "map和forEach都是JavaScript数组的迭代方法，但它们之间存在一些关键区别。\n\n返回值：map方法会返回一个新的数组，这个新数组是由原数组通过某个函数处理后的结果组成的。而forEach方法则没有返回值，它仅仅是对数组中的每个元素执行一次给定的函数。\n修改原数组：forEach方法可以直接修改原数组，而map方法则不会改变原数组，而是创建一个全新的数组。\n性能：在大多数现代浏览器中，map的性能通常优于forEach。"
    },
    {
      "question":"Javascript 浅拷贝/深度拷贝的区别？",
      "answer": "在 JavaScript 中，浅拷贝和深拷贝都是用来复制对象的，但它们复制的深度不同。\n\n浅拷贝（Shallow Copy）： 浅拷贝只复制对象的顶层属性。如果对象的属性值是基本类型（如数字、字符串、布尔值），那么就直接复制这个值；如果属性值是引用类型（如对象、数组），那么复制的是这个值的引用，而不是实际的对象或数组。这就意味着，如果你修改了新对象的一个引用类型的属性，那么原对象的对应属性也会被修改。\n深拷贝（Deep Copy）： 深拷贝不仅复制对象的顶层属性，还会递归地复制所有的子属性。无论属性值是基本类型还是引用类型，都会创建一个新的副本。这就意味着，新对象和原对象完全独立，修改其中一个不会影响另一个。"
    },
    {
      "question":"阐述Javascript的同源策略？",
      "answer": "同源策略（Same-origin policy）是一种重要的安全策略，它被用于限制从同一源加载的文档或脚本如何与来自其他源的资源进行交互。这是一种防止恶意行为的重要安全机制。\n在JavaScript中，如果两个网页的协议，端口（如果有的话）和主机都相同，那么这两个网页属于同源。\n同源策略的主要影响包括：\n1.Cookie、LocalStorage 和 IndexDB 无法读写。\n2.DOM 无法获得和操作。\n3.AJAX 请求不能发送。"
    },
    {
      "question":"JavaScript事件委托是什么 ？",
      "answer": "事件委托是一种 JavaScript 中的事件处理模式，它利用了事件冒泡的机制，将事件监听器添加到一个父元素上，而不是分别添加到各个子元素上。当触发子元素上的事件时，通过冒泡，事件会传播到父元素，然后在父元素上的监听器处理这个事件。\n\n事件委托有以下几个优点：\n\n提高性能：如果有许多子元素需要监听同一事件，那么在每个子元素上单独添加事件监听器将会消耗大量性能。而通过在父元素上添加一个事件监听器来处理所有子元素的事件，可以显著提高性能。\n处理动态元素：如果在运行时添加了新的子元素，那么这些新元素自动继承了父元素的事件监听器。这对于处理动态添加的元素非常有用，否则你需要在添加新元素时，再次为新元素绑定事件。"
    },
    {
      "question":"JavaScript 中有多少个线程？",
      "answer": "JavaScript是一种单线程的语言，这意味着在任何给定的时间点，JavaScript都只能执行一个任务。这是由于JavaScript最初是为了与浏览器交互而设计的，它的主要目标是操作DOM，处理用户交互，发送网络请求等，这些任务在大多数情况下都不需要多线程。\n\n然而，这并不意味着JavaScript不能执行并行操作。尽管JavaScript是单线程的，但它使用了事件循环（Event Loop）机制，可以处理异步操作。这些异步操作（如网络请求、定时器等）在开始时被放入任务队列（Task Queue），然后在主线程空闲时被取出执行。这样，即使JavaScript是单线程的，也可以处理并行操作，提高效率。\n\n此外，HTML5引入了Web Workers API，它允许JavaScript创建多个后台线程执行任务，这些线程是完全独立的，它们不能访问DOM或者其他Web API，但可以发送信息到主线程，让主线程进行UI操作。这在一些需要大量计算的场景下非常有用，可以避免阻塞主线程，提高页面的响应速度。"
    },
    {
      "question":"简述Vue的MVVM 模式?",
      "answer": "MVVM模式是Model-View-ViewModel的缩写，是一种设计思想。MVVM模式分为三部分：\n\nModel（模型）：负责数据的存储以及处理问题的部分，它代表的是你的数据和业务逻辑。在Vue中，Model就是我们在data中声明的数据。\nView（视图）：负责数据展示的部分，简单来说，就是用户看到并与之交互的界面。在Vue中，View就是我们写的模板。\n\nViewModel（视图模型）：它是连接View和Model的桥梁。在Vue中，ViewModel就是Vue实例。Vue实例在创建时，会接收data对象，并遍历此对象所有的属性，并使用Object.defineProperty将属性全部转为getter/setter，以便追踪属性的变化。当用户在View层进行操作时，ViewModel能感知到变化并对Model层的数据进行更新，反之亦然。\n\nMVVM的最大优点就是数据驱动和双向数据绑定，即Model变化会自动更新到View，反之View变化也会自动改变Model。这种方式让开发者只需关注业务逻辑，不需要手动操作DOM，极大地提高了开发效率。"
    },
    {
      "question":" Vue 2.0 响应式数据的原理？",
      "answer": "Vue 2.0 的响应式系统的核心是 Object.defineProperty，它允许 Vue 跟踪依赖，并在属性被访问和修改时通知变更。以下是 Vue 2.0 响应式数据的原理：\n1.当你把一个普通的 JavaScript 对象传给 Vue 实例的 data 选项，Vue 将遍历此对象所有的属性，并使用 Object.defineProperty 把这些属性全部转为 getter/setter。\n2.每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据属性记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。\n3.Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际（已去重的）工作。\n4.Vue 在内部尝试对异步队列使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。\n通过这种方式，Vue 能够智能地知道何时更新视图，而无需在数据变化时手动操作 DOM，这大大提高了应用的效率。"
    },
    {
      "question":"v-model 双向绑定的原理是什么？",
      "answer": "v-model 是 Vue.js 中的一个重要指令，它实现了数据和表单元素之间的双向绑定。简单来说，双向绑定就是数据改变会影响视图，视图改变也会影响数据。\n\nv-model 的双向绑定原理主要基于以下两个部分：\n\n数据到视图的绑定：这一部分主要通过 Vue 的响应式系统完成。当我们在组件的 data 中定义一个变量，例如 message，Vue 会使用 Object.defineProperty() 方法将它转换为 getter/setter。当我们在模板中使用 {{message}} 或 v-model=\"message\" 时，Vue 会将当前组件添加到 message 的依赖中。当 message 发生变化时，Vue 会通知所有依赖 message 的组件重新渲染，从而更新视图。\n视图到数据的绑定：这部分主要通过监听 DOM 事件完成。对于 <input> 元素，v-model 指令会监听 input 事件。当用户在输入框中输入内容时，触发 input 事件，然后 v-model 指令的事件处理函数会把新的值赋给 message，从而更新数据。"
    },
    {
      "question": "isNaN 和 Number.isNaN 函数的区别？",
      "answer": "函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。\n函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。"
    },
    {
      "question": "v-if和v-show的区别",
      "answer": "● 手段：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；\n● 编译过程：v-if切换有一个局部编译/卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；\n● 编译条件：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；\n● 性能消耗：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；\n● 使用场景：v-if适合运营条件不大可能改变；v-show适合频繁切换。"
    },
    {
      "question": "'+'操作符什么时候用于字符串的拼接？",
      "answer": "根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。\n\n简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。\n\n简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。"
    },
    {
      "question": "const对象的属性可以修改吗",
      "answer": "const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。\n\n但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。"
    },
    {
      "question": "简述虚拟DOM的概念和机制 ？",
      "answer":"虚拟DOM（Virtual DOM）是React的一项核心特性，它是对真实DOM的抽象表达，是一个轻量级的JavaScript对象。\n\n在React中，当组件的状态改变时，React并不会直接去更新真实的DOM。相反，它会创建一个新的虚拟DOM，这个虚拟DOM代表了在状态改变后应用的新状态。然后，React会将这个新的虚拟DOM与旧的虚拟DOM进行比较，这个过程叫做”diffing”。通过比较，React可以找出两个虚拟DOM之间的区别，也就是哪些部分需要更新。最后，React会将这些差异应用到真实的DOM上，这个过程叫做”reconciliation”或”协调”。这种方式称为DOM diffing算法。\n虚拟DOM的主要优势在于其性能。操作真实DOM在浏览器中是非常消耗性能的。而使用虚拟DOM，React可以最小化真实DOM的更新，从而提高性能和应用的响应速度。"
    },
    {
      "question": "React 类组件和函数组件之间的区别是什么？",
      "answer":"React提供了两种主要的方式来创建组件：类组件（Class Components）和函数组件（Function Components）。以下是它们之间的主要区别：\n1.定义方式： 类组件是使用ES6的类来定义的，需要继承React.Component。而函数组件则是简单的JavaScript函数。\n2.状态管理： 在React的早期版本中，类组件是唯一可以使用内部状态（state）的组件类型。函数组件是无状态的，只能接收props。但是从React 16.8版本开始，引入了Hooks这个新特性，使得函数组件也可以使用状态以及其他React特性了。\n3.生命周期方法： 类组件提供了生命周期方法，如 componentDidMount，componentDidUpdate，componentWillUnmount等。而在引入Hooks之前，函数组件无法使用这些生命周期方法。但是现在，通过使用 useEffect Hook，函数组件也可以模拟生命周期方法的行为。\n4.使用方式： 类组件需要使用this关键字来访问props和状态，而函数组件则可以直接访问这些值。"
    },
    {
      "question": "Redux 请求中间件如何处理并发 ？",
      "answer":"Redux 中间件是 Redux 架构中的关键部分，用于处理异步操作和副作用。当我们在 Redux 中处理 API 请求或其他异步操作时，我们通常会使用 Redux 中间件，例如 Redux-Thunk、Redux-Saga 或 Redux-Observable 等。\n\n这些中间件处理并发请求的方式各有不同：\n\nRedux-Thunk：Redux-Thunk 是一个简单的中间件，它允许你在 action 创建函数中返回一个函数，而不是一个普通的 action 对象。这个函数可以接收 dispatch 和 getState 作为参数，以便在需要的时候派发新的 action 或者读取当前的状态。当你需要处理并发请求时，你可以使用 Promise.all 或者其他 Promise 方法来处理。\nRedux-Saga：Redux-Saga 使用 ES6 的 Generator 功能，使得异步流程控制更加直观，写起来更像同步代码。Redux-Saga 提供了非阻塞调用（fork）和并发调用（all）等高级功能，可以很好地处理并发请求。\n\nRedux-Observable：Redux-Observable 基于 RxJS，提供了强大的异步流程控制能力。你可以利用 RxJS 提供的各种操作符来处理并发请求，例如 mergeMap、concatMap、switchMap 等。"
    }
  ]
}