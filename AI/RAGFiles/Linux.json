{
  "questions": [
    {
      "question": "设计模型可以被分成哪些？",
      "answer": "创建型模式：涉及到对象的创建机制，帮助创建对象时同时隐藏创建逻辑，而不是使用new直接实例化对象。这些模式提供了创建对象的最佳方式。例如，单例模式（Singleton）保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n结构型模式：关注类和对象的组合，继承的替代方案，用于将接口和实现分离开来帮助我们得到更大的结构。例如，适配器模式（Adapter）可以让不兼容的接口通过一定的转换能够一起工作。\n\n行为型模式：关注对象之间的通信，这些模式提供了增强对象间责任划分和算法封装的方法。例如，观察者模式（Observer）定义了对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。"
    },
    {
      "question": "简述Linux系统的开机启动顺序？",
      "answer": "1.BIOS/UEFI阶段：当你开启电脑时，首先执行的是基本输入输出系统（BIOS）或统一可扩展固件接口（UEFI）。它负责进行硬件的自检（POST），检查系统的基本配置，并且查找启动设备（如硬盘、USB设备等）。\n2.引导加载器阶段：在Linux中，常见的引导加载器有GRUB（GRand Unified Bootloader）或LILO（Linux Loader）。BIOS/UEFI将控制权交给引导加载器，引导加载器会显示一个菜单，让你选择要启动的操作系统（如果有多个操作系统的话）。例如，GRUB会显示一个列表，包括Linux内核的不同版本和其他操作系统（如Windows）。\n3.内核加载阶段：选择操作系统后，引导加载器加载选定的内核到内存中。内核是操作系统的核心部分，负责管理硬件资源和提供系统服务。\n4.init进程启动：内核加载完毕后，它会启动一个特殊的进程，称为init（或在一些新的系统中使用systemd或Upstart作为替代）。这个进程是用户空间进程的祖先。它负责启动其他所有的系统进程。\n5.运行级别（Runlevels）/目标（Targets）：init或systemd根据配置启动一系列的脚本或服务，这些脚本或服务负责启动系统上的各种功能和服务。例如，设置网络、启动图形用户界面（GUI）等。在使用systemd的系统中，这些被称为“目标”（targets），而在传统的使用SysVinit的系统中，这些被称为运行级别（runlevels）。\n6.用户登录：所有必要的服务都启动后，系统会显示登录提示符或图形登录界面，等待用户登录。"
    },
    {
      "question": "Linux系统中符号链接与硬链接的区别？",
      "answer": "在Linux系统中，符号链接（Symbolic Link）和硬链接（Hard Link）是两种不同类型的链接，用于指向文件。\n1.符号链接（Symbolic Link）\n定义：符号链接，也称为软链接，是一种特殊类型的文件，它包含的是另一个文件或目录的路径。它仅仅是指向另一个文件的指针。\n特点：可以跨文件系统链接。可以链接到目录。如果删除了原文件，符号链接将失效，显示为悬空链接。\n符号链接文件本身有独立的inode（文件系统中的索引节点）。\n2.硬链接（Hard Link）\n定义：硬链接是另一个文件的另一个名称，它指向相同的文件内容和inode。在文件系统中，所有的文件名实际上都是硬链接，指向存储数据的inode。\n特点：不能跨文件系统链接。不能链接到目录（为了防止产生循环）。\n如果删除了原文件，任何硬链接都仍然可以访问文件的内容。\n硬链接和其原始文件共享相同的inode。"
    },
    {
      "question": "简述RHEL与CentOS的区别？",
      "answer": "Red Hat Enterprise Linux (RHEL) 和 CentOS 是两个紧密相关的Linux发行版，它们之间的主要区别在于支持和商业模式。以下是它们之间的关键区别：\n\nRed Hat Enterprise Linux (RHEL)\n商业发行版：RHEL是一个商业产品，由Red Hat公司开发和支持。用户需要购买订阅来获取软件更新、安全补丁和官方支持服务。\n稳定性和安全性：RHEL专注于稳定性和安全性，适合企业级部署。它通过严格的测试和认证过程，确保与各种硬件和软件兼容。\n付费支持：RHEL的用户可以获得Red Hat的专业支持，包括技术支持和咨询服务。\nCentOS\n社区发行版：CentOS是RHEL的社区版，它由社区志愿者维护，提供与RHEL二进制兼容的免费发行版。CentOS遵循RHEL的源代码重新编译，但移除了Red Hat的商标和图形标识。\n免费使用：CentOS完全免费，包括其提供的软件更新和安全补丁。然而，它没有官方的商业支持，社区论坛和邮件列表提供支持。\n适用性：CentOS适合那些需要企业级操作系统稳定性但没有商业支持需求的用户和组织。\n主要变化\n值得注意的是，从2021年开始，CentOS的发展方向发生了变化。CentOS Linux（传统的CentOS项目）被CentOS Stream取代，这是一个介于Fedora和RHEL之间的发行版，旨在为下一个RHEL版本提供一个预览。CentOS Stream现在作为RHEL的上游（即，RHEL之前的测试和开发阶段），这意味着它比RHEL更加前沿，但可能不如传统的CentOS那样稳定。\n\n总结\nRHEL提供商业支持和认证，适合需要全面支持和服务的企业环境。\nCentOS（特别是传统的CentOS）提供了一个与RHEL兼容的免费平台，适合预算有限或不需要商业支持的用户。\nCentOS Stream提供了一个查看即将到来的RHEL变化的窗口，适合开发者和那些愿意参与测试新功能的用户。"
    },
    {
      "question": "Linux下硬盘分区表示方法？",
      "answer": "在Linux下，硬盘分区表示方法是通过特定的命名约定来识别不同的硬盘和分区。这种命名方式依赖于硬盘的类型（IDE/SATA或SCSI/SAS/SSD等）和分区的顺序。下面是一些基本的命名规则：\n1.IDE/SATA硬盘（传统的PATA和现代的SATA接口）\n硬盘：Linux系统中，IDE或SATA硬盘被表示为/dev/sdX，其中X是一个字母，表示硬盘的顺序。例如，第一个检测到的硬盘被称为/dev/sda，第二个为/dev/sdb，依此类推。\n分区：硬盘上的分区被表示为硬盘名后跟一个数字。例如，/dev/sda1表示/dev/sda硬盘上的第一个分区，/dev/sda2表示第二个分区，以此类推。\n2.SCSI/SAS/SSD硬盘\n对于SCSI、SAS（串行附加SCSI）和SSD硬盘，命名约定也是使用/dev/sdX格式，跟IDE/SATA硬盘相同。这种统一的命名方法简化了不同类型硬盘的管理。\n分区命名规则也与IDE/SATA硬盘相同，即硬盘名后跟一个数字来表示分区。\n3.NVMe硬盘\n硬盘：使用NVMe接口的SSD硬盘有不同的命名规则，被表示为/dev/nvmeXnY，其中X代表控制器编号，Y代表命名空间。NVMe SSD可以支持多个命名空间，这使得单个物理设备可以被分割成多个逻辑单元。\n分区：NVMe硬盘上的分区命名在硬盘命名后面加上p再加上分区编号。例如，/dev/nvme0n1p1表示第一个NVMe硬盘的第一个分区。"
    },
    {
      "question": "常见的Linux目录结构？",
      "answer": "Linux系统的目录结构遵循文件系统层次结构标准（FHS），这提供了一个标准化的目录和文件的组织方式。以下是一些Linux系统中常见的目录及其用途的简介：\n\n/（根目录）\n所有文件和目录在Linux中都从根目录开始。\n/bin（用户二进制文件）\n包含用户级别的程序和命令，如ls、cp等。这些命令对所有用户都可用。\n/sbin（系统二进制文件）\n存放系统管理员使用的系统管理命令，如fdisk、sysctl等。\n/etc（配置文件）\n包含系统的配置文件。这些文件通常是文本文件，可以被编辑来改变系统的设置。\n/dev（设备文件）\n包含所有设备和特殊文件的位置。在Linux中，设备被视为文件，可以像操作文件一样操作这些设备。\n/proc（进程信息）\n一个虚拟的文件系统，包含运行中的系统进程和内核信息。它不占用磁盘空间，主要用于系统监控目的。\n/var（可变文件）\n存放经常变化的文件，如日志文件（/var/log）、包和数据库文件。\n/tmp（临时文件）\n用于存放临时文件，系统重启时，这个目录下的文件可能会被删除。\n/usr（用户程序）\n包含用户应用程序和文件。它通常包含多个子目录，如/usr/bin、/usr/sbin、/usr/local等，用于不同类型的用户级程序和数据。\n/home（用户主目录）\n存放普通用户的个人数据和配置文件。每个用户都有一个以其用户名命名的目录。\n/root（root用户的主目录）\nroot用户的个人主目录，而不是/home/root。\n/boot（启动加载器文件）\n包含启动Linux系统时使用的文件，如内核映像和引导加载程序（GRUB或LILO）的配置文件。\n/lib（系统库）\n存放系统和应用程序使用的共享库文件，以及内核模块。"
    },
    {
      "question": "简述DNS进行域名解析的过程？",
      "answer": "域名系统（DNS）的域名解析过程是将人类可读的网站域名（如 www.example.com）转换为机器可读的IP地址（如 192.0.2.1）的过程。这个过程涉及多个步骤和多个DNS服务器。以下是域名解析的基本步骤：\n\n1. 浏览器缓存\n当用户在浏览器中输入一个网址时，解析过程首先检查浏览器缓存中是否有该网址的IP地址记录，因为浏览器会缓存DNS查询结果以减少未来的查询时间。\n2. 系统缓存\n如果浏览器缓存中没有找到记录，系统会检查本地DNS缓存是否有该域名的解析记录。\n3. 路由器缓存\n如果本地缓存中也没有找到，查询会继续向路由器发送，路由器同样可能缓存了DNS查询结果。\n4. 互联网服务提供商（ISP）的DNS服务器\n如果前面的步骤都没有找到记录，请求会被发送到用户的ISP的DNS服务器。这些服务器将有更大的DNS缓存，可能会直接返回域名对应的IP地址。\n5. 根DNS服务器\n如果ISP的DNS服务器也无法解析，它会查询根DNS服务器。根服务器是最高级别的DNS服务器，它不直接知道域名的IP地址，但能指向负责该顶级域（TLD，例如.com、.net等）的DNS服务器。\n6. 顶级域（TLD）DNS服务器\n根服务器会返回一个指向相应顶级域DNS服务器的地址。这些服务器负责管理在该顶级域下注册的所有域名的信息。\n7. 权威DNS服务器\n顶级域DNS服务器再将请求指向负责该具体域名的权威DNS服务器。这个服务器有该域名的最终解析记录，包含对应的IP地址。\n8. 响应返回\n权威DNS服务器回复包含IP地址的响应给ISP的DNS服务器，ISP的服务器再将这个响应返回给用户的计算机。然后，用户的计算机会使用这个IP地址与目标服务器建立连接。\n9. 缓存结果\n最后，解析结果会被缓存于各级（浏览器、操作系统、路由器等），以便后续查询能更快地获取到IP地址。\n这个过程虽然看起来步骤繁多，但实际上通常在几百毫秒内完成。DNS的这种分层和缓存机制大大提高了互联网的效率和性能。"
    },
    {
      "question": "Linux系统的开机启动项如何选择？",
      "answer": "Linux系统的开机启动项选择通常通过配置引导加载器来实现。引导加载器是在系统启动过程中运行的程序，它负责加载操作系统内核。最常见的两个引导加载器是GRUB（GRand Unified Bootloader）和LILO（Linux Loader），其中GRUB是现代Linux系统中更常见的选择。以下是如何选择开机启动项的基本步骤，主要以GRUB为例：\n配置GRUB来选择启动项\n1.查看当前GRUB配置：\nGRUB的配置文件通常位于/boot/grub/grub.cfg或/boot/grub2/grub.cfg，但直接编辑这个文件不是推荐的做法，因为它会在更新内核或运行update-grub命令时被自动生成覆盖。\n推荐的做法是修改/etc/default/grub文件或在/etc/grub.d/目录下的配置脚本。\n2.修改GRUB配置文件：\n打开/etc/default/grub文件进行编辑。你可以使用文本编辑器，如nano或vim：\n“`bash\nsudo nano /etc/default/grub\n“`\n\n找到GRUB_DEFAULT行。这里可以设置默认的启动项，可以是菜单项的索引（从0开始计数），也可以是菜单项的完整标题（需要完全匹配）。\n\n例如：使用数字指定默认启动项（例如，GRUB_DEFAULT=0将选择第一个菜单项）。\n使用菜单项标题（例如，GRUB_DEFAULT=\"Ubuntu, with Linux 5.4.0-42-generic\"）。\n3.更新GRUB配置：\n在修改了/etc/default/grub文件之后，需要运行update-grub或grub2-mkconfig命令来更新GRUB的配置。\n“`bash\nsudo update-grub\n“`\n\n或者对于某些发行版：\n\n“`bash\nsudo grub2-mkconfig -o /boot/grub2/grub.cfg\n“`\n\n这个命令会根据/etc/default/grub文件和/etc/grub.d/目录下的脚本生成新的grub.cfg文件。\n\n4.重启系统：\n完成上述步骤后，重启系统。在启动时，GRUB会按照新配置显示启动菜单，并自动选择你指定的默认启动项。\n注意事项:在进行任何更改之前，建议备份原始的GRUB配置文件。对于双启动系统，确保正确识别并选择了你想要作为默认系统的操作系统。\n在某些情况下，特别是使用UEFI启动的系统，可能需要通过系统的固件设置（BIOS设置）来选择启动设备或操作系统。\n"
    },
    {
      "question": "Linux运行级别0-6的各自含义？",
      "answer": "Linux系统的运行级别（Runlevels）是由System V init进程控制的一种模式，定义了系统启动和关闭的不同状态。每个运行级别代表了系统的一个特定状态，如单用户模式、多用户网络模式等。以下是传统的System V风格init系统中定义的运行级别0到6的含义：\n\n运行级别0\n关机（Halt）：此运行级别会关闭系统。\n运行级别1\n单用户模式（Single-User Mode）：这是一种维护或紧急修复模式，此时只有根用户可以登录，不启动网络服务，一般用于系统维护。\n运行级别2\n多用户模式，不带NFS（Multi-User Mode without NFS）：这个级别允许多用户登录但不启动网络文件系统（NFS），在不同的Linux发行版中这个模式的具体含义可能有所不同。\n运行级别3\n完全的多用户模式（Full Multi-User Mode）：这是标准的多用户模式，支持多用户登录并启动网络服务，但不启动图形用户界面（GUI）。\n运行级别4\n未定义：保留未使用，可以被个别Linux发行版特定地定义用途。\n运行级别5\n图形模式（X11）：与运行级别3相似，但在此基础上启动图形用户界面（GUI），是大多数桌面Linux发行版的默认运行级别。\n运行级别6\n重启（Reboot）：此运行级别会重启系统。"
    },
    {
      "question": "包过滤防火墙与代理应用防火墙有什么区别？",
      "answer": "包过滤防火墙和代理应用防火墙（也称为应用层防火墙）是网络安全中两种常见的防火墙技术。它们在处理和管理数据包的方式上有显著的不同，下面是它们各自的特点和区别：\n\n包过滤防火墙\n工作层级：包过滤防火墙工作在网络层（第3层）和传输层（第4层）。\n功能：它根据数据包的头信息（如源IP地址、目的IP地址、TCP/UDP端口号等）进行过滤。包过滤防火墙检查经过的每个数据包，并根据预设的规则决定是否允许数据包通过。\n性能：由于只检查数据包的头部信息，包过滤防火墙对系统资源的消耗较低，处理速度快。\n限制：它不能理解数据包的实际内容（即应用层数据）。因此，包过滤防火墙无法对应用层攻击（如SQL注入、跨站脚本攻击等）提供保护。\n代理应用防火墙（应用层防火墙）\n工作层级：代理应用防火墙工作在应用层（第7层）。\n功能：它不仅基于IP地址和端口号过滤数据，还能理解和分析经过的流量内容。代理应用防火墙可以检查、过滤或修改进出的应用数据，如HTTP、HTTPS请求。\n性能：由于需要深入分析数据内容，代理应用防火墙对系统资源的消耗更大，处理速度可能比包过滤防火墙慢。\n优势：能够提供更高级的安全功能，包括保护应用免受特定的应用层攻击，如Web应用攻击、SQL注入等。\n主要区别\n数据处理深度：包过滤防火墙只检查数据包的头部信息，而代理应用防火墙则深入到应用层，检查数据的实际内容。\n安全级别：代理应用防火墙提供更高级的安全保护，可以防御复杂的应用层攻击，而包过滤防火墙主要防御基于IP和端口的攻击。\n性能影响：包过滤防火墙对性能的影响相对较小，处理速度快；代理应用防火墙由于进行深度的内容检查，对性能的影响较大，处理速度慢。\n在实际应用中，为了达到最佳的安全性和性能平衡，很多网络环境会同时使用包过滤防火墙和代理应用防火墙。通过这种方式，可以在不同的网络层级提供全面的保护。"
    },
    {
      "question": "什么是DDOS攻击？怎么预防？",
      "answer": "DDoS（分布式拒绝服务）攻击是一种常见的网络攻击手段，目的是通过大量生成的网络流量来使目标服务器或网络资源过载，从而导致合法用户无法访问这些资源。攻击者通常利用多个被控制的网络设备（称为“僵尸网络”）发起攻击，这些设备分布在全球各地，因此称为“分布式”。\n\nDDoS攻击的类型\nDDoS攻击有多种形式，包括但不限于：\n\nVolumetric Attacks：通过大量的流量淹没目标，消耗网络带宽。\nProtocol Attacks：利用协议缺陷消耗目标资源或网络设备资源。\nApplication Layer Attacks：针对特定应用层服务的攻击，如HTTP、DNS等，旨在使这些服务不可用。\n怎么预防DDoS攻击？\n防御DDoS攻击是一个复杂的过程，需要在多个层面上采取措施：\n1.基础网络架构加固\n采用冗余网络架构，分散流量风险。\n配置网络设备（如路由器和防火墙）的速率限制，以防止过载。\n使用高容量的网络硬件和带宽，提高网络抗压能力。\n2.入侵检测和防御系统\n部署入侵检测系统（IDS）和入侵防御系统（IPS），监控异常流量并自动响应。\n3.防DDoS解决方案\n使用专业的DDoS防御服务，如云端DDoS保护服务。这些服务可以在攻击达到目标之前就“洗净”恶意流量。\n4.应用层保护\n对于针对特定应用的攻击，部署应用层防火墙和Web应用防火墙（WAF）来识别和阻止恶意请求。\n5.响应计划\n准备一个DDoS攻击响应计划，确保快速有效地缓解攻击影响。计划应包括联系信息、预定的响应流程和恢复步骤。\n6.带宽过载保护\n和互联网服务提供商（ISP）合作，实施流量清洗措施或紧急路由变更。\n7.常规监控和分析\n持续监控网络流量和行为，使用分析工具识别异常模式，以便及时发现攻击迹象。"
    },
    {
      "question": "Linux 中的用户模式和内核模式是什么含意？",
      "answer": "在Linux操作系统（以及其他类Unix系统）中，用户模式（User Mode）和内核模式（Kernel Mode）是指CPU的两种不同的运行级别或状态，这两种模式主要是为了提供系统的安全性和稳定性。\n1.内核模式（Kernel Mode）\n含义：在内核模式下，CPU可以执行任何指令，访问系统的所有内存地址和硬件资源。操作系统的核心部分（内核）在这个模式下运行，负责管理硬件设备、管理内存、处理系统调用等低级任务。\n特权级别：这是一种高特权状态，允许执行所有CPU指令和访问所有硬件资源。\n安全性：由于内核模式具有对系统的完全控制，任何在内核模式下运行的错误代码都可能导致系统崩溃或安全漏洞。因此，只有受信任的操作系统代码应在内核模式下执行。\n2.用户模式（User Mode）\n含义：用户模式是一个受限制的执行模式，用于运行用户程序和应用软件。在用户模式下，程序不能直接执行某些保护系统安全和稳定性的操作（如直接访问硬件资源）。\n特权级别：这是一种低特权状态，某些CPU指令（特权指令）和对硬件资源的直接访问在用户模式下是不允许的。如果用户程序需要进行这些操作，它必须通过系统调用向内核请求服务，内核代表程序执行这些操作。\n安全性：用户模式通过限制程序的能力来增加系统的安全性和稳定性。即使用户程序崩溃，也不会直接影响到系统的核心部分。\n3.用户模式和内核模式的切换\n系统调用：当用户程序需要执行文件操作、网络通信或其他需要内核介入的操作时，它会执行系统调用。这会导致CPU从用户模式切换到内核模式，并执行相应的内核函数。完成后，CPU切换回用户模式，继续执行用户程序。\n中断和异常：当发生硬件中断或异常时，CPU也会从用户模式切换到内核模式，以便内核处理这些事件。\n通过这种模式的区分，Linux操作系统能够提供一个既安全又稳定的环境，既能允许用户程序执行广泛的任务，又能防止这些程序干扰系统的正常运行或彼此的运行。"
    },
    {
      "question": "Linux 调度程序是根据进程的动态优先级还是静态优先级 来调度进程的？",
      "answer": "Linux调度程序主要根据进程的动态优先级来调度进程，尽管进程创建时会根据其类型（实时或非实时）和用户指定的优先级设置一个静态优先级。动态优先级是为了确保系统的响应性和公平性，允许调度器根据进程的行为和需要动态调整其优先级。\n1.静态优先级\n定义：进程的静态优先级是在进程创建时设置的，并且在进程的整个生命周期中不变。对于非实时进程，这通常是一个从0到19的数字，其中0是最高优先级，19是最低（默认值通常为10或20）。对于实时进程，静态优先级的范围是1到99，数值越大，优先级越高。\n用途：静态优先级主要用于初始化进程的优先级，并为调度决策提供一个基准点。\n2.动态优先级\n定义：动态优先级是调度器根据进程的运行情况动态调整的优先级。对于非实时进程，Linux的完全公平调度器（CFS）会根据进程的运行时间和睡眠时间等因素调整其动态优先级，以实现公平的处理器时间分配。\n特点：动态优先级确保了长时间运行的进程不会持续占用CPU资源而不给其他进程运行的机会，同时也确保了需要频繁交互的进程（如用户界面进程）能够获得足够的CPU时间来响应用户操作。\n3.实时进程\n对于实时进程，Linux提供了两种实时调度策略：SCHED_FIFO（先进先出）和SCHED_RR（时间片轮转）。这些进程根据其静态优先级进行调度，但在相同优先级的进程中，SCHED_RR策略会在进程间进行时间片轮转。实时进程的优先级通常高于非实时进程，确保了关键任务能够及时执行。\n总的来说，Linux调度程序主要是基于动态优先级进行进程调度的，这允许系统更灵活地响应运行时条件的变化，确保了系统资源的高效和公平使用。静态优先级提供了一个起始点，但进程的实际调度顺序会根据其行为和系统策略动态调整。"
    },
    {
      "question": "Linux 通过什么方式实现系统调用？",
      "answer": "Linux通过一种被称为软件中断的机制实现系统调用。在x86架构上，这通常是通过int 0x80指令或syscall指令（在较新的处理器上）实现的。这些指令使得用户空间的程序可以请求内核空间提供的服务，如文件操作、进程控制、网络通信等。\n\n系统调用的过程\n系统调用接口：应用程序通过标准库（如C库，即libc）提供的包装函数，如open()、read()、write()等，发起系统调用。这些函数封装了实际的系统调用编号和提供给内核的参数。\n触发软件中断：库函数内部将执行一个特定的指令（int 0x80或syscall），这个指令将CPU从用户模式切换到内核模式。这是因为系统调用需要由操作系统内核来执行，而内核运行在受保护的内核模式下。\n系统调用处理：内核通过系统调用表（syscall table）根据传入的系统调用编号，找到对应的内核函数并执行。系统调用表是内核中的一个数组，包含了所有系统调用处理函数的指针。\n返回用户空间：系统调用完成后，结果（成功或失败）会被返回给用户空间的调用者，CPU模式从内核模式切换回用户模式，应用程序继续执行。"
    },
    {
      "question": "Linux 软中断和工作队列的作用是什么？",
      "answer": "在Linux内核中，软中断（Softirqs）和工作队列（Workqueues）是处理非紧急任务和底层驱动程序中断处理的两种机制。它们使得内核能够在不干扰关键内核活动的情况下，异步地执行任务。这两种机制在设计和用途上有所不同，但都旨在提高系统的效率和响应性。\n1.软中断（Softirqs）\n作用：软中断是一种低开销的中断机制，用于处理可延迟的任务，如网络数据包的接收和发送、定时器处理等。它们是在中断上下文中执行的，意味着它们不能被普通的进程抢占，但可以被硬件中断（Hardirqs）抢占。\n设计目的：软中断的主要设计目的是减少硬件中断处理程序（Hardirqs）的执行时间。通过将部分工作延迟到软中断中，硬件中断处理程序可以快速返回，从而减少系统对硬件中断的响应时间。\n特点：\n软中断可以并发运行在多个CPU上。\n软中断的执行不能被其他软中断或任务抢占，但可以被硬件中断抢占。\n适用于处理需要快速响应但不需要立即完成的任务。\n2.工作队列（Workqueues）\n作用：工作队列提供了一种机制，允许内核将需要在进程上下文中执行的长时间运行的任务排队。这些任务可能包括设备驱动程序的底层任务，如磁盘I/O操作、文件系统的延迟写入等。\n设计目的：工作队列允许任务在进程上下文中异步执行，这意味着它们可以睡眠（等待资源、睡眠锁等），这在中断上下文中是不允许的。\n特点：\n工作队列任务在特定的内核线程中执行，这些线程可以被普通进程和软中断抢占。\n适用于不需要立即处理的任务，特别是那些可能需要睡眠的任务。\n提供了更大的灵活性，可以处理复杂的任务，但相比软中断和硬件中断处理程序，其开销较大。\n总结\n软中断主要用于处理需要较快处理但可以稍微延迟的中断驱动任务，例如在接收到大量网络数据包时快速处理它们。\n工作队列用于处理那些可能需要较长时间、可能需要睡眠的任务，它们在进程上下文中执行，提供了执行复杂操作的能力。\n通过这两种机制，Linux内核能够有效地管理和调度各种类型的任务，确保系统的高性能和响应性。"
    },
    {
      "question": "Linux磁盘分区表主要有哪两种格式 ？",
      "answer": "Linux磁盘分区表主要有两种格式：MBR（Master Boot Record）和GPT（GUID Partition Table）。\n\nMBR（Master Boot Record）\n概述：MBR是较旧的分区方案，自1983年以来一直被广泛使用。它位于磁盘的最开始部分，包含启动信息和一个分区表，描述磁盘上的分区布局。\n容量限制：MBR仅支持最大2TB（TeraBytes）的磁盘大小和最多4个主分区。如果需要更多分区，则必须创建一个扩展分区来容纳逻辑分区。\n兼容性：MBR具有很好的兼容性，几乎所有的操作系统都支持MBR分区表。\nGPT（GUID Partition Table）\n概述：GPT是一种新的分区方案，设计来替代MBR，解决MBR的一些限制。它是UEFI（统一可扩展固件接口）规范的一部分。\n容量限制：GPT支持的磁盘大小远超2TB，理论上可以支持到ZB（ZettaBytes）级别，且可以创建多达128个主分区（在某些操作系统中这个数目可以更高）。\n兼容性：虽然新的操作系统都支持GPT，但在一些旧系统或旧设备上可能存在兼容性问题。GPT通常与UEFI引导方式一起使用，而非传统的BIOS。\n主要区别\n容量和分区数量：GPT支持更大的磁盘容量和更多的分区数量。\n数据完整性：GPT提供更强的数据完整性保护。它在磁盘上多个位置存储分区表的副本，并使用CRC32校验分区表的完整性。\n引导方式：MBR与传统的BIOS引导方式相结合，而GPT则是为了与UEFI引导方式相兼容而设计的。\n在选择磁盘分区表格式时，通常考虑磁盘大小、操作系统兼容性以及是否需要支持UEFI引导等因素。对于新安装的系统和大容量硬盘，推荐使用GPT分区表。"
    },
    {
      "question": "Linux 文件系统通过 i 节点把文件的逻辑结构和物理结构转换的工作过程？",
      "answer": "在Linux文件系统中，i节点（inode）是文件系统的基本组成部分，用于存储文件的元数据，但不包含文件名或文件数据内容。每个文件或目录在文件系统中都有一个唯一的i节点，其中包含了该文件的所有信息（如文件权限、所有者、大小、时间戳、数据块位置等），除了文件名。文件名与i节点号的映射存储在目录的数据块中，这样设计是为了将文件的逻辑结构（如文件树、目录层次等）与其物理结构（如数据存储位置）分离，从而提高文件系统的灵活性和效率。\n\n工作过程\n文件名解析：当访问一个文件时，操作系统首先解析文件路径，从根目录开始，逐级查找每个目录的数据块，以确定文件名对应的i节点号。每个目录都是一个特殊的文件，存储了该目录下所有文件和子目录的名称及其对应的i节点号。\n访问i节点：一旦得到文件的i节点号，系统就会在i节点表中查找该i节点。i节点表是文件系统的一部分，存储了所有i节点的信息。\n\n读取文件数据：i节点包含了文件数据块的地址信息，操作系统根据这些地址信息读取磁盘上的数据块，组装成文件数据。对于大文件，i节点中可能直接存储一部分数据块地址，同时使用间接地址指针指向其他包含更多地址信息的数据块，形成一个多级索引结构。\n\n更新i节点：如果对文件进行了修改，操作系统会更新i节点中的相关信息（如修改时间、文件大小等），并可能重新分配数据块。文件的修改不影响其i节点号，确保了文件的唯一性和一致性。\n\n特点\n元数据和数据分离：通过i节点系统，Linux文件系统将文件的元数据与实际数据分离开来，提高了文件访问和管理的效率。\n硬链接：Linux文件系统支持硬链接，即多个文件名指向同一个i节点。由于i节点号是唯一的，这些硬链接实际上是不同的入口点指向同一份文件数据，共享相同的i节点。\n数据安全和完整性：i节点系统允许文件系统在不改变文件逻辑结构的前提下，灵活地管理物理数据的存储，如数据块的分配和回收，有助于提高数据的安全性和完整性。\ni节点是Linux文件系统管理文件的核心机制，通过抽象和分离文件的逻辑与物理结构，实现了高效、灵活且安全的文件存储和访问方式。"
    },
    {
      "question": "Linux 中的浮点运算由应用程序实现还是内核实现?",
      "answer": "在Linux中，浮点运算主要由应用程序实现，而不是由内核直接实现。这是因为浮点运算通常是在用户空间的应用程序中进行的，利用处理器的浮点运算单元（FPU）或通过软件库进行数学运算。\n\n应用程序中的浮点运算\n应用程序可以直接使用CPU的浮点指令集来执行浮点运算，这种方式依赖于硬件的支持，并且运行在用户模式下。\n对于复杂的数学运算，应用程序通常会使用数学库（如GNU科学库GSL、Intel数学核心库MKL等），这些库提供了优化过的数学运算函数，包括浮点运算，以提高性能。\n内核中的浮点运算\nLinux内核主要负责管理硬件资源、进程调度、内存管理等系统级任务。虽然内核代码中可能包含一些浮点运算，但这是非常罕见的，因为内核运行在内核模式下，需要保证高度的稳定性和效率。内核中的浮点运算使用需要非常小心，以避免对系统稳定性造成影响。\n内核避免在执行路径中使用浮点运算，主要是因为处理浮点上下文切换的开销较大，并且内核需要保持在任何时候都能快速响应中断。保存和恢复浮点状态会增加延迟。\n浮点上下文切换\n当操作系统在进程之间切换时，需要保存和恢复CPU的状态，包括浮点单元的状态。这确保了当进程被重新调度运行时，它的浮点环境保持不变。\nLinux内核负责管理这种上下文切换，包括浮点寄存器的保存和恢复，以确保每个进程的浮点运算环境互不干扰。\n总的来说，虽然浮点运算的管理（如上下文切换中的状态保存和恢复）是由内核负责的，但实际的浮点运算操作是在用户空间的应用程序中执行的，利用硬件或软件实现的数学运算功能。这种设计允许应用程序充分利用硬件资源，同时保持内核的简洁和稳定。"
    },
    {
      "question": "Linux 如何唯一标识一个设备?",
      "answer": "在Linux系统中，设备可以通过多种方式被唯一标识。这些标识符提供了一种方法来持久地引用设备，即使设备的名称或连接顺序发生变化。以下是一些主要的设备唯一标识方式：\n\n1. 设备文件（Device Files）\nLinux使用设备文件来表示硬件设备。这些特殊的文件位于/dev目录下，例如/dev/sda（第一个SATA硬盘）、/dev/tty1（第一个终端设备）、/dev/loop0（第一个循环设备）等。虽然设备文件本身不是设备的唯一标识符，但它们是与设备进行交互的接口。\n\n2. UUID（Universally Unique Identifier）\nUUID是设备或分区的全局唯一标识符。对于文件系统、交换分区和其他可识别的分区，UUID在创建时生成并存储在元数据中。UUID的一个常见用途是在/etc/fstab文件中引用设备，以确保即使设备名变化，系统也能准确挂载正确的分区。可以使用blkid命令查看设备的UUID。\n\n3. LABEL\nLABEL是分区或文件系统的标签，由用户定义。像UUID一样，LABEL也可用于/etc/fstab中，提供了一种易于理解和管理的方式来引用设备。LABEL的优点是它们可以是有意义的名称，如DATA、BACKUP等。\n\n4. 设备路径（Device Path）\n设备路径是指设备在系统硬件树中的位置，通常用于表示USB设备和其他通过热插拔接口连接的设备。这些路径可以通过/sys文件系统查看，例如/sys/class/net/eth0或/sys/block/sda。设备路径提供了一种方式来引用设备，独立于它们的设备文件名。\n\n5. 硬件地址\n硬件设备，如网络接口卡，还可以通过其硬件地址（如MAC地址）被唯一标识。这些地址是由制造商分配的，对于网络设备而言，可以确保在全球范围内的唯一性。\n\n6. 系统设备树（Sysfs）和Udev数据库\nsysfs文件系统和udev数据库提供了设备的详细信息，包括制造商、型号、序列号等，可以用于唯一标识设备。udev系统还允许基于这些属性创建持久的设备名称规则。\n\n总的来说，Linux提供了多种方法来唯一标识设备，从而允许系统管理员和系统自身以一种一致和可预测的方式管理和引用这些设备。这些标识方式的选择取决于具体的应用场景和管理需求。"
    },
    {
      "question": "块设备和字符设备有什么区别？",
      "answer": "在Linux和其他类Unix操作系统中，设备主要分为两类：块设备（Block Devices）和字符设备（Character Devices），它们在系统中以不同的方式处理数据。\n\n块设备\n数据处理方式：块设备以固定大小的块（通常为512字节或更大）为单位读写数据。这意味着即使要读写的数据量小于一个块的大小，操作系统也会处理一个完整的块。\n例子：硬盘驱动器、固态硬盘、USB闪存驱动器等。\n特点：\n支持随机访问：可以直接读写存储在任何位置的数据块。\n通常用于存储文件系统。\n数据可以被缓存：出于性能考虑，操作系统可以缓存块设备的数据，延迟写入操作。\n字符设备\n数据处理方式：字符设备以字节为单位顺序处理数据，通常不支持随机访问。数据按照顺序一个接一个地传输，没有缓冲。\n例子：键盘、鼠标、串口、打印机等。\n特点：\n数据直接从设备读取或直接写入设备，不经过缓冲区。\n主要用于输入/输出设备，支持流式数据传输。\n主要区别\n访问模式：块设备支持随机访问，允许访问任意位置的数据块；字符设备处理流式数据，通常以顺序方式访问。\n数据单位：块设备以块（一组字节）为单位处理数据；字符设备以单个字符（字节）为单位处理数据。\n缓存：块设备的数据可以被缓存，提高数据访问效率；字符设备的数据通常不被缓存，直接传输。\n使用场景\n块设备：适用于需要大量数据存储和频繁随机访问的场景，如文件系统存储。\n字符设备：适用于需要按顺序处理数据的场景，如终端输入/输出和某些类型的硬件接口。\n在实际应用中，这两种设备类型提供了对硬件资源的抽象，使得操作系统能够以统一和高效的方式管理各种不同的硬件设备。"
    },
    {
      "question": "Linux 内核 IO 模型 ？",
      "answer": "Linux内核支持多种I/O模型，这些模型定义了应用程序和操作系统之间数据传输的行为和方式。不同的I/O模型在性能、资源消耗和编程复杂性方面各有优劣。Linux主要提供以下五种I/O模型：\n\n1. 阻塞I/O（Blocking I/O）\n特点：在阻塞I/O操作中，应用程序发起I/O请求后会被挂起（阻塞），直到I/O操作完成（数据被复制到用户空间）才返回。在此期间，应用程序不能执行其他任务。\n应用场景：简单的应用程序，不关心程序的并发或吞吐量。\n2. 非阻塞I/O（Non-blocking I/O）\n特点：应用程序发起I/O请求后不会被挂起，如果数据未准备好，调用会立即返回一个错误（通常是EAGAIN或EWOULDBLOCK）。应用程序可以继续执行其他任务，但需要不断轮询I/O状态，检查数据是否准备就绪。\n应用场景：需要提高程序响应性的应用程序，或在等待I/O操作时执行其他任务的应用程序。\n3. I/O复用（I/O Multiplexing）\n特点：I/O复用允许应用程序同时监视多个I/O流的状态，使用如select、poll或epoll系统调用等待多个I/O流中的任意一个变得可用。当有I/O流准备好时，应用程序会被唤醒。\n应用场景：适用于需要处理多个并发连接的服务器程序，如Web服务器、数据库服务器。\n4. 信号驱动I/O（Signal-driven I/O）\n特点：应用程序首先对一个I/O流进行信号驱动（异步）I/O配置，然后继续执行，直到I/O操作准备就绪时，一个信号被发送到应用程序，通知它I/O操作可以进行了。\n应用场景：适用于不想频繁轮询但又希望异步处理I/O的应用程序。\n5. 异步I/O（Asynchronous I/O）\n特点：应用程序发起异步I/O操作后会立即返回，操作系统负责将数据传输到用户空间，当整个I/O操作完成后，应用程序会收到通知。应用程序无需等待I/O操作的完成，也无需轮询检查状态。\n应用场景：高性能服务器和需要高吞吐量的应用程序，适用于需要处理大量并发I/O操作，同时最小化延迟和资源消耗的场景。\n这些I/O模型各有适用场景，开发者可以根据应用程序的具体需求选择最合适的模型以达到最佳的性能和资源利用率。"
    },
    {
      "question": "Linux启动过程中几个重要配置文件的执行过程 ？",
      "answer": "Linux启动过程涉及多个配置文件，这些文件在系统启动时被读取和执行，以设置系统环境和启动服务。不同的Linux发行版可能会有所不同，特别是在使用System V init和systemd作为init系统时。以下是一些在Linux启动过程中常见的重要配置文件及其执行过程：\n\n1. /etc/fstab\n描述：/etc/fstab文件包含了文件系统的挂载信息，指定了哪些磁盘或分区需要在启动时自动挂载，以及挂载参数。\n执行过程：在系统启动过程中，init系统（无论是System V init还是systemd）会读取/etc/fstab文件，根据其中的信息挂载必要的文件系统。\n2. /etc/default/grub\n描述：对于使用GRUB作为引导加载器的系统，/etc/default/grub包含了GRUB的配置选项，如默认启动项、启动延时和内核启动参数等。\n执行过程：在更新GRUB配置（使用update-grub或grub2-mkconfig命令）后，更改会被应用到/boot/grub/grub.cfg，GRUB在系统启动时读取这个文件。\n3. /etc/rc.local\n描述：在使用System V init的系统中，/etc/rc.local是一个脚本，可以用来执行系统完全启动后需要运行的命令。\n执行过程：/etc/rc.local通常是在系统启动过程中最后执行的脚本。\n4. /etc/init.d/ 和 /etc/rc*.d/\n描述：对于System V init系统，/etc/init.d/目录包含了服务的启动脚本，而/etc/rc*.d/目录包含了指向这些脚本的符号链接，这些链接按启动级别（runlevel）组织。\n执行过程：在系统启动时，init进程会根据当前的运行级别（runlevel），执行/etc/rc*.d/目录下相应级别的启动脚本。\n5. /etc/systemd/system/ 和 /lib/systemd/system/\n描述：对于使用systemd作为init系统的Linux发行版，服务的单元文件（unit files）存放在这些目录中。这些单元文件定义了服务、挂载点、设备等的配置。\n执行过程：在系统启动时，systemd读取这些单元文件，按照依赖关系启动服务和其他资源。"
    },
    {
      "question": "二层交换机和三层交换机的区别 ?",
      "answer": "二层交换机（Layer 2 Switch）和三层交换机（Layer 3 Switch）在网络中扮演着不同的角色，主要区别在于它们操作的网络层级以及相应的功能：\n2.二层交换机（Layer 2 Switch）\n工作层级：二层交换机工作在数据链路层（OSI模型的第二层）。它使用MAC地址（媒体访问控制地址）来转发数据帧。\n主要功能：\nMAC地址表：根据MAC地址表进行数据帧的转发或过滤。\nVLAN支持：能够实现虚拟局域网（VLAN）划分，控制不同VLAN间的数据流。\n自学习：能够自动学习和更新MAC地址表。\n用途：主要用于同一网络（广播域）内部的数据转发，不能跨越不同网络。\n2.三层交换机（Layer 3 Switch）\n工作层级：三层交换机工作在网络层（OSI模型的第三层）。它使用IP地址来进行数据包的路由。\n主要功能：\n路由功能：能够进行IP路由，根据IP地址和路由表将数据包转发到不同的网络或子网。\nVLAN间路由：除了支持VLAN，还能实现不同VLAN间的路由，即VLAN间通信。\n策略路由：支持更复杂的路由策略，如基于策略的路由、访问控制列表（ACL）等。\n用途：既可以像二层交换机一样转发数据帧，也能实现跨网络的路由功能，适用于网络的汇聚层或核心层。\n3.主要区别\n操作层级：二层交换机在数据链路层使用MAC地址处理数据，而三层交换机在网络层使用IP地址进行数据路由。\n功能：二层交换机主要负责同一局域网内的数据帧转发，三层交换机除了具备二层交换机的功能外，还能进行跨网络的路由。\n应用场景：二层交换机适用于接入层，为局域网内部的设备提供连接；三层交换机多用于网络的核心层和汇聚层，连接不同的网络和子网，实现网络间的通信。\n简而言之，二层交换机更多关注局域网内的通信，而三层交换机则在此基础上增加了跨网络通信的能力。"
    },
    {
      "question": "Linux 有哪些系统日志文件?",
      "answer": "Linux 系统中有多种日志文件，它们记录了系统的不同方面的信息，帮助系统管理员和开发人员了解系统状态和诊断问题。以下是一些常见的系统日志文件：\n1./var/log/messages：这是最常见的日志文件之一，用于存储全局系统消息，包括启动信息、系统错误、硬件错误等。它对于诊断系统问题非常有用。\n2./var/log/auth.log：这个日志文件专门用于记录认证日志，比如用户登录、sudo 命令的使用等。在 Debian 基础的系统中，这个文件非常重要，用于追踪系统访问和安全事件。\n3./var/log/secure：在基于 Red Hat 的系统中（如 CentOS、Fedora），这个文件的功能与 /var/log/auth.log 类似，用于存储认证日志和安全相关的信息。\n4./var/log/syslog：这个文件包含了系统除了上述内容之外的其他消息。不同程序和服务的日志信息都可能被记录在这里，具体取决于系统的配置。\n5./var/log/boot.log：此日志文件包含系统启动过程中的消息，可以帮助诊断启动过程中的问题。\n6./var/log/dmesg：此文件包含内核产生的消息，如硬件驱动和接口信息，非常重要，用于诊断硬件相关的问题。\n7./var/log/kern.log：包含内核产生的消息，主要用于诊断和记录与内核相关的事件。\n8./var/log/cron.log：记录了cron 守护进程的日志信息，包括计划任务的执行情况。\n9./var/log/mail.log：用于记录邮件服务器的日志信息，如发送和接收邮件的记录。\n10./var/log/apache2/access.log 和 /var/log/apache2/error.log（对于 Apache Web 服务器）或者 /var/log/nginx/access.log 和 /var/log/nginx/error.log（对于 Nginx Web 服务器）：这些日志文件分别记录了 Web 服务器的访问日志和错误日志。\n\n这些日志文件是系统管理员日常检查的重要资源，通过它们可以监控系统健康状况、诊断问题以及进行安全审计。不同的发行版可能会有所差异，但大体上都包含这些日志文件或类似的功能文件。"
    },
    {
      "question": "Nginx 是如何实现高并发的？",
      "answer": "Nginx 实现高并发的关键在于其事件驱动的异步架构。这种设计使得Nginx能够以非常高效的方式处理成千上万的并发连接，同时保持低内存和CPU的使用。下面是Nginx实现高并发的几个主要机制：\n\n事件驱动模型：Nginx使用事件驱动模型来处理请求，这意味着每个工作进程都能非阻塞地处理多个连接。当数据准备好读取或写入时，事件就会被触发，Nginx工作进程响应这些事件进行处理。这样，一个进程就可以同时处理多个连接的读写请求，而不是为每个连接分配一个单独的进程或线程。\n非阻塞I/O：Nginx的所有I/O操作（如网络读写、与文件系统的交互）都是非阻塞的。这意味着当请求一个I/O操作时，Nginx不会挂起等待操作完成，而是继续处理其他任务，直到I/O操作完成时再回来处理相关的任务。这避免了I/O操作的等待时间影响整体性能。\n\n一主多工作进程：Nginx采用一主多工作进程的架构。主进程负责管理工作进程，包括创建、终止和维护工作进程的健康状态。每个工作进程都能独立处理连接，这样就可以充分利用多核CPU的能力，提高并发处理能力。\n\n负载均衡：在反向代理和负载均衡的使用场景中，Nginx可以将客户端请求均匀地分发到多个后端服务器，这样可以避免单个服务器因处理过多请求而过载，提高整体的处理能力和可用性。\n\n高效的内存管理：Nginx对内存的使用进行了优化，能够在处理大量连接时保持较低的内存消耗。它通过复用连接对象和缓冲区减少内存分配和回收的开销，从而提高性能。\n\n静态文件处理和缓存机制：对于静态内容，Nginx使用高效的算法直接从操作系统内核缓存中提供文件，减少磁盘I/O操作。此外，Nginx的缓存机制可以缓存动态内容的输出，减少对后端服务器的请求，进一步提高处理速度。"
    },
    {
      "question": "Linux Vim三种工作模式 ？",
      "answer": "Linux Vim编辑器的三种主要工作模式是命令模式（Normal Mode）、插入模式（Insert Mode）和末行模式（Command-line Mode）。每种模式都有其特定的用途和操作方式，了解这些模式对于高效使用Vim至关重要。\n\n1. 命令模式（Normal Mode）\n用途：此模式下，可以使用键盘命令来浏览文档、删除、复制粘贴文本等。它是Vim启动后的默认模式。\n如何进入：在其他模式下按Esc键可以返回到命令模式。\n示例命令：\nh、j、k、l：分别向左、下、上、右移动光标。\ndd：删除当前行。\nyy：复制当前行。\np：粘贴文本。\n2. 插入模式（Insert Mode）\n用途：此模式下，可以直接输入文本，编辑文件内容。\n如何进入：在命令模式下，可以通过按i（在光标前插入）、a（在光标后插入）、o（在当前行下面插入新行）等命令进入插入模式。\n退出：按Esc键返回命令模式。\n3. 末行模式（Command-line Mode）\n用途：此模式允许输入一些在命令行中执行的命令，如保存文件、查找替换文本、配置编辑器行为等。\n如何进入：在命令模式下，按:（冒号）进入末行模式。\n示例命令：\n:w：保存文件。\n:q：退出Vim。\n:wq或:x：保存并退出。\n:/pattern：搜索文本。\n通过掌握这三种模式及其转换，用户可以充分利用Vim的强大功能，高效地进行文本编辑和处理。每种模式都有其专门的指令集，熟练使用这些指令可以大幅提高文本处理的速度和效率。"
    }
  ]
}